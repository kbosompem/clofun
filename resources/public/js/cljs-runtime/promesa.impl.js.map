{"version":3,"sources":["promesa/impl.cljc"],"mappings":"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","names":["promesa.impl/promise?","v","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","promesa.protocols/IPromise","promesa.impl/deferred?","promesa.protocols/ICompletable","promesa.impl/resolved","promesa.impl.promise/resolved","promesa.impl/rejected","promesa.impl.promise/rejected","promesa.impl/coerce","promesa.impl.promise/coerce","promesa.impl/all","promises","promesa.impl.promise/all","cljs.core.into_array","promesa.protocols/-fmap","cljs.core/vec","promesa.impl/race","promesa.impl.promise/race","cljs.core.map","promesa.protocols/-promise","promesa.impl/deferred","promesa.impl.promise/deferred","promesa.impl/extend-promise!","t","p","js/Promise","promesa.impl.promise/PromiseImpl","it","f","p1__46817#","e","p1__46818#","p1__46819#","executor","p1__46820#","p1__46821#","p1__46822#","p1__46823#","p1__46824#","p1__46825#","p1__46826#","p1__46827#","p1__46828#","value","default","var_args","G__46865","promesa.impl/unwrap","js/Error","promesa.protocols/-mcat","promesa.protocols/IPromiseFactory","promesa.impl/promise->str","writer","opts","cljs.core/-write","promesa.protocols/-pending?","promesa.protocols/-cancelled?","promesa.protocols/-rejected?","cljs.core/hash"],"sourcesContent":[";; This Source Code Form is subject to the terms of the Mozilla Public\n;; License, v. 2.0. If a copy of the MPL was not distributed with this\n;; file, You can obtain one at http://mozilla.org/MPL/2.0/.\n;;\n;; Copyright (c) Andrey Antukh <niwi@niwi.nz>\n\n(ns ^:no-doc promesa.impl\n  \"Implementation of promise protocols.\"\n  (:require\n   [clojure.core :as c]\n   [promesa.protocols :as pt]\n   [promesa.util :as pu]\n   [promesa.exec :as exec]\n   #?(:cljs [promesa.impl.promise :as impl]))\n\n  #?(:clj\n     (:import\n      java.time.Duration\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionException\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.CountDownLatch\n      java.util.concurrent.ExecutionException\n      java.util.concurrent.Executor\n      java.util.concurrent.Future\n      java.util.concurrent.TimeUnit\n      java.util.concurrent.TimeoutException\n      java.util.function.Function\n      java.util.function.Supplier)))\n\n;; --- Global Constants\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  (satisfies? pt/IPromise v))\n\n(defn deferred?\n  \"Return true if `v` is a deferred instance.\"\n  [v]\n  (satisfies? pt/ICompletable v))\n\n(defn resolved\n  [v]\n  #?(:cljs (impl/resolved v)\n     :clj (CompletableFuture/completedFuture v)))\n\n(defn rejected\n  [v]\n  #?(:cljs (impl/rejected v)\n     :clj (let [p (CompletableFuture.)]\n            (.completeExceptionally ^CompletableFuture p v)\n            p)))\n\n#?(:cljs\n   (defn coerce\n     \"Coerce a thenable to built-in promise impl type.\"\n     [v]\n     (impl/coerce v)))\n\n(defn all\n  [promises]\n  #?(:cljs (-> (impl/all (into-array promises))\n               (pt/-fmap vec))\n     :clj (let [promises (map pt/-promise promises)]\n            (-> (CompletableFuture/allOf (into-array CompletableFuture promises))\n                (pt/-fmap (fn [_] (mapv pt/-extract promises)))))))\n\n(defn race\n  [promises]\n  #?(:cljs (impl/race (into-array (map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (into-array CompletableFuture (map pt/-promise promises)))))\n\n;; --- Promise Impl\n\n(defn deferred\n  []\n  #?(:clj (CompletableFuture.)\n     :cljs (impl/deferred)))\n\n#?(:cljs\n   (defn extend-promise!\n     [t]\n     (extend-type t\n       pt/IPromiseFactory\n       (-promise [p] (impl/coerce p)))))\n\n\n#?(:cljs (extend-promise! js/Promise))\n#?(:cljs (extend-promise! impl/PromiseImpl))\n\n#?(:cljs\n   (extend-type impl/PromiseImpl\n     pt/IPromiseFactory\n     (-promise [p] p)\n\n     pt/IPromise\n     (-fmap\n       ([it f] (.fmap it #(f %)))\n       ([it f e] (.fmap it #(f %))))\n\n     (-mcat\n       ([it f] (.fbind it #(f %)))\n       ([it f executor] (.fbind it #(f %))))\n\n     (-hmap\n       ([it f] (.fmap it #(f % nil) #(f nil %)))\n       ([it f e] (.fmap it #(f % nil) #(f nil %))))\n\n     (-merr\n       ([it f] (.fbind it pt/-promise #(f %)))\n       ([it f e] (.fbind it pt/-promise #(f %))))\n\n     (-fnly\n       ([it f] (.handle it f) it)\n       ([it f executor] (.handle it f) it))\n\n     (-then\n       ([it f] (.then it #(f %)))\n       ([it f executor] (.then it #(f %))))\n\n     pt/ICompletable\n     (-resolve! [it v]\n       (.resolve ^js it v))\n     (-reject! [it v]\n       (.reject ^js it v))\n\n     pt/ICancellable\n     (-cancel! [it]\n       (.cancel it))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     cljs.core/IDeref\n     (-deref [it]\n       (let [value (unchecked-get it \"value\")]\n         (if (.isRejected it)\n           (throw value)\n           value)))\n\n     pt/IState\n     (-extract\n       ([it]\n        (unchecked-get it \"value\"))\n       ([it default]\n        (if (.isPending it)\n          default\n          (unchecked-get it \"value\"))))\n\n     (-resolved? [it]\n       (.isResolved it))\n\n     (-rejected? [it]\n       (.isRejected it))\n\n     (-pending? [it]\n       (.isPending it))))\n\n(defn- unwrap\n  ([v]\n   (if (promise? v)\n     (pt/-mcat v unwrap)\n     (pt/-promise v)))\n  ([v executor]\n   (if (promise? v)\n     (pt/-mcat v unwrap executor)\n     (pt/-promise v))))\n\n#?(:clj\n   (extend-protocol pt/IPromise\n     CompletionStage\n     (-fmap\n       ([it f]\n        (.thenApply ^CompletionStage it\n                    ^Function (pu/->Function f)))\n\n       ([it f executor]\n        (.thenApplyAsync ^CompletionStage it\n                         ^Function (pu/->Function f)\n                         ^Executor (exec/resolve-executor executor))))\n\n     (-mcat\n       ([it f]\n        (.thenCompose ^CompletionStage it\n                      ^Function (pu/->Function f)))\n\n       ([it f executor]\n        (.thenComposeAsync ^CompletionStage it\n                           ^Function (pu/->Function f)\n                           ^Executor (exec/resolve-executor executor))))\n\n     (-hmap\n       ([it f]\n        (.handle ^CompletionStage it\n                 ^BiFunction (pu/->Function2 f)))\n\n       ([it f executor]\n        (.handleAsync ^CompletionStage it\n                      ^BiFunction (pu/->Function2 f)\n                      ^Executor (exec/resolve-executor executor))))\n\n     (-merr\n       ([it f]\n        (-> ^CompletionStage it\n            (.handle ^BiFunction (pu/->Function2 #(if %2 (f %2) it)))\n            (.thenCompose ^Function pu/f-identity)))\n\n       ([it f executor]\n        (-> ^CompletionStage it\n            (.handleAsync ^BiFunction (pu/->Function2 #(if %2 (f %2) it))\n                          ^Executor (exec/resolve-executor executor))\n            (.thenCompose ^Function pu/f-identity))))\n\n     (-then\n       ([it f]\n        (pt/-mcat it (fn [v] (unwrap (f v)))))\n\n       ([it f executor]\n        (pt/-mcat it (fn [v] (unwrap (f v) executor)) executor)))\n\n     (-fnly\n       ([it f]\n        (.whenComplete ^CompletionStage it\n                       ^BiConsumer (pu/->Consumer2 f)))\n\n       ([it f executor]\n        (.whenCompleteAsync ^CompletionStage it\n                            ^BiConsumer (pu/->Consumer2 f)\n                            ^Executor (exec/resolve-executor executor))))\n\n     ))\n\n#?(:clj\n   (extend-type Future\n     pt/ICancellable\n     (-cancel! [it]\n       (.cancel it true))\n     (-cancelled? [it]\n       (.isCancelled it))))\n\n#?(:clj\n   (extend-type CompletableFuture\n     pt/ICancellable\n     (-cancel! [it]\n       (.cancel it true))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     pt/ICompletable\n     (-resolve! [f v] (.complete f v))\n     (-reject! [f v] (.completeExceptionally f v))\n\n     pt/IState\n     (-extract\n       ([it]\n        (try\n          (.getNow it nil)\n          (catch ExecutionException e\n            (.getCause e))\n          (catch CompletionException e\n            (.getCause e))))\n       ([it default]\n        (try\n          (.getNow it default)\n          (catch ExecutionException e\n            (.getCause e))\n          (catch CompletionException e\n            (.getCause e)))))\n\n     (-resolved? [it]\n       (and (.isDone it)\n            (not (.isCompletedExceptionally it))))\n\n     (-rejected? [it]\n       (and (.isDone it)\n            (.isCompletedExceptionally it)))\n\n     (-pending? [it]\n       (not (.isDone it)))))\n\n#?(:clj\n   (extend-protocol pt/IAwaitable\n     Thread\n     (-await!\n       ([it] (.join ^Thread it))\n       ([it duration]\n        (if (instance? Duration duration)\n          (.join ^Thread it ^Duration duration)\n          (.join ^Thread it (int duration)))))\n\n     CountDownLatch\n     (-await!\n       ([it]\n        (.await ^CountDownLatch it))\n       ([it duration]\n        (if (instance? Duration duration)\n          (.await ^CountDownLatch it (long (inst-ms duration)) TimeUnit/MILLISECONDS)\n          (.await ^CountDownLatch it (long duration) TimeUnit/MILLISECONDS))))\n\n     CompletableFuture\n     (-await!\n       ([it]\n        (try\n          (.get ^CompletableFuture it)\n          (catch ExecutionException e\n            (throw (.getCause e)))\n          (catch CompletionException e\n            (throw (.getCause e)))))\n\n       ([it duration]\n        (let [ms (if (instance? Duration duration) (inst-ms duration) duration)]\n          (try\n            (.get ^CompletableFuture it (int ms) TimeUnit/MILLISECONDS)\n            (catch ExecutionException e\n              (throw (.getCause e)))\n            (catch CompletionException e\n              (throw (.getCause e)))))))\n\n     CompletionStage\n     (-await!\n       ([it]\n        (pt/-await! (.toCompletableFuture ^CompletionStage it)))\n       ([it duration]\n        (pt/-await! (.toCompletableFuture ^CompletionStage it) duration)))))\n\n;; --- Promise Factory\n\n;; This code is responsible of coercing the incoming value to a valid\n;; promise type. In some cases we will receive a valid promise object,\n;; in this case we return it as is. This is useful when you want to\n;; `then` or `map` over a plain value that can be o can not be a\n;; promise object\n\n#?(:clj\n   (extend-protocol pt/IPromiseFactory\n     CompletionStage\n     (-promise [cs] cs)\n\n     Throwable\n     (-promise [e]\n       (rejected e))\n\n     Object\n     (-promise [v]\n       (resolved v))\n\n     nil\n     (-promise [v]\n       (resolved v)))\n\n   :cljs\n   (extend-protocol pt/IPromiseFactory\n     js/Error\n     (-promise [e]\n       (rejected e))\n\n     default\n     (-promise [v]\n       (resolved v))))\n\n;; --- Pretty printing\n\n(defn promise->str\n  [p]\n  \"#<js/Promise[~]>\")\n\n#?(:clj\n   (defmethod print-method java.util.concurrent.CompletionStage\n     [p ^java.io.Writer writer]\n     (let [status (cond\n                    (pt/-pending? p)   \"pending\"\n                    (pt/-cancelled? p) \"cancelled\"\n                    (pt/-rejected? p)  \"rejected\"\n                    :else              \"resolved\")]\n       (.write writer ^String (format \"#<CompletableFuture[%s:%d]>\" status (hash p))))))\n\n#?(:cljs\n   (extend-type js/Promise\n     IPrintWithWriter\n     (-pr-writer [p writer opts]\n       (-write writer \"#<js/Promise[~]>\"))))\n\n#?(:cljs\n   (extend-type impl/PromiseImpl\n     IPrintWithWriter\n     (-pr-writer [p writer opts]\n       (-write writer (str \"#<Promise[\"\n                           (cond\n                             (pt/-pending? p)   \"pending\"\n                             (pt/-cancelled? p) \"cancelled\"\n                             (pt/-rejected? p)  \"rejected\"\n                             :else              \"resolved\")\n                           \":\" (hash p)\n                           \"]>\")))))\n"]}