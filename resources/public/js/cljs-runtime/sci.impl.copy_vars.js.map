{"version":3,"sources":["sci/impl/copy_vars.cljc"],"mappings":"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","names":["sci.impl.copy-vars/inlined-vars","sci.impl.copy-vars/cljs-resolve","js/cljs","js/cljs.analyzer","js/cljs.analyzer.api","js/cljs.analyzer.api.resolve","cljs.core/Var","cljs.analyzer.api/resolve","sci.impl.copy-vars/elide-vars","var_args","G__40823","sci.impl.copy-vars/macrofy*","js/Error","f","p1__40798#","cljs.core.vary_meta","cljs.core.assoc","sym","sci.impl.copy_vars.macrofy_STAR_","ns","ctx?","extra-meta","or__5045__auto__","sci.impl.utils/clojure-core-ns","sci.impl.utils.new_var","G__40832","and__5043__auto__","cljs.core.merge","G__40834","sci.impl.copy-vars/new-var","sci.impl.copy_vars.new_var","cljs.core/boolean?","sci.lang/Namespace","G__40854"],"sourcesContent":["(ns sci.impl.copy-vars\n  {:no-doc true}\n  (:require\n   [sci.impl.cljs]\n   [sci.impl.macros :as macros]\n   [sci.impl.utils :as utils :refer [clojure-core-ns]]\n   [sci.lang])\n  #?(:cljs (:require-macros [sci.impl.copy-vars :refer [copy-var copy-core-var macrofy]])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; The following is produced with:\n;; (def inlined (filter (comp :inline meta) (vals (ns-publics 'clojure.core))))\n;; (map (comp :name meta) inlined)\n(def inlined-vars\n  '#{+' unchecked-remainder-int unchecked-subtract-int dec' short-array bit-shift-right aget = boolean bit-shift-left aclone dec < char unchecked-long unchecked-negate unchecked-inc-int floats pos? boolean-array alength bit-xor unsigned-bit-shift-right neg? unchecked-float num reduced? booleans int-array inc' <= -' * min get long double bit-and-not unchecked-add-int short quot unchecked-double longs unchecked-multiply-int int > unchecked-int unchecked-multiply unchecked-dec double-array float - byte-array zero? unchecked-dec-int rem nth nil? bit-and *' unchecked-add identical? unchecked-divide-int unchecked-subtract / bit-or >= long-array object-array doubles unchecked-byte unchecked-short float-array inc + aset chars ints bit-not byte max == count char-array compare shorts unchecked-negate-int unchecked-inc unchecked-char bytes})\n\n(def cljs-resolve (resolve 'cljs.analyzer.api/resolve))\n\n#?(:clj (def elide-vars (= \"true\" (System/getenv \"SCI_ELIDE_VARS\")))\n   ;; for self-hosted\n   :cljs (def elide-vars false))\n\n(macros/deftime\n\n  (defn ensure-quote [x]\n    (if (and (seq? x) (= 'quote (first x)))\n      x\n      (list 'quote x)))\n\n  (defn dequote [x]\n    (if (and (seq? x) (= 'quote (first x)))\n      (second x)\n      x))\n\n  (defn core-sym [sym]\n    (symbol \"clojure.core\" (name sym)))\n\n  (defn var-meta [&env sym opts & _a]\n    (let [sym (dequote sym)\n          macro (when opts (:macro opts))\n          nm (when opts (:name opts))\n          [fqsym sym] (if (qualified-symbol? sym)\n                     [sym (symbol (name sym))]\n                     [(symbol \"clojure.core\" (str sym)) sym])\n          inline (contains? inlined-vars sym)\n          fast-path (or (= 'or sym)\n                        (= 'and sym)\n                        (= 'case sym)\n                        (= 'ns sym)\n                        (= 'lazy-seq sym))\n          varm (merge (cond-> {:name (or nm (list 'quote (symbol (name sym))))}\n                    macro (assoc :macro true)\n                    inline (assoc :sci.impl/inlined (:inlined opts fqsym)))\n                  (let [#?@(:clj [the-var (macros/? :clj (resolve fqsym)\n                                                    :cljs (atom nil))])]\n                    (macros/? :clj #?(:clj  (let [m (meta the-var)\n                                                  dyn (:dynamic m)\n                                                  arglists (:arglists m)]\n                                              (cond-> (if elide-vars {} {:doc (:doc m)})\n                                                dyn (assoc :dynamic dyn)\n                                                (if elide-vars false arglists)\n                                                (assoc :arglists (list 'quote (:arglists m)))\n                                                fast-path (assoc :sci.impl/fast-path (list 'quote sym))))\n                                      :cljs nil)\n                              :cljs (let [r (cljs-resolve &env fqsym)\n                                          m (:meta r)\n                                          dyn (:dynamic m)\n                                          arglists (or (:arglists m) (:arglists r))]\n                                      (cond-> {:arglists (ensure-quote arglists)\n                                               :doc (or (:doc m) (:doc r))}\n                                        dyn (assoc :dynamic dyn)\n                                        arglists (assoc :arglists (ensure-quote arglists))\n                                        fast-path (assoc :sci.impl/fast-path (list 'quote sym)))))))]\n      #_(when (= 'inc sym)\n        (prn varm))\n      varm))\n\n  (defmacro macrofy [& args]\n    (let [[sym & args] args]\n      `(macrofy* ~sym ~@args ~@(repeat (- 3 (count args)) nil) ~(var-meta &env sym nil))))\n\n\n  ;; Note: self hosted CLJS can't deal with multi-arity macros so this macro is split in 2\n  #?(:clj\n     (if elide-vars\n         (binding [*out* *err*]\n           (println \"SCI: eliding vars.\"))\n       nil))\n  (defmacro copy-var\n    [sym ns & [opts]]\n    (let [macro (:macro opts)\n          #?@(:clj [the-var (macros/? :clj (resolve sym)\n                                      :cljs (atom nil))])\n          dyn (:dynamic opts)\n          varm (cond-> (assoc (var-meta &env (or (:name opts)\n                                                 (:copy-meta-from opts)\n                                                 sym)\n                                        opts)\n                              :sci/built-in true\n                              :ns ns)\n                 dyn (assoc :dynamic dyn))\n          nm (:name varm)\n          ctx (:ctx opts)\n          init (:init opts sym)]\n      ;; NOTE: emit as little code as possible, so our JS bundle is as small as possible\n      (if macro\n        (macros/? :clj\n                  #?(:clj  `(sci.lang.Var. ~(deref the-var) ~nm ~varm false ~ctx nil)\n                     :cljs `(sci.lang.Var. ~init ~nm ~varm false ~ctx nil))\n                  :cljs `(sci.lang.Var. ~init ~nm ~varm false ~ctx nil))\n        (if elide-vars\n            (if (or dyn ctx)\n              `(sci.lang.Var. ~init ~nm ~varm false ~ctx nil)\n              sym)\n           `(sci.lang.Var. ~init ~nm ~varm false ~ctx nil)))))\n  (defmacro copy-core-var\n    [sym]\n    `(copy-var ~sym clojure-core-ns {:copy-meta-from ~(core-sym sym)}))\n\n  )\n\n(defn macrofy*\n  ([f] (vary-meta f #(assoc % :sci/macro true)))\n  ([sym f] (macrofy* sym f nil false))\n  ([sym f ns] (macrofy* sym f ns false))\n  ([sym f ns ctx?] (macrofy* sym f ns ctx? nil))\n  ([sym f ns ctx? extra-meta]\n   (let [ns (or ns clojure-core-ns)]\n     (utils/new-var sym f (cond-> {:ns ns\n                                   :macro true\n                                   :sci/built-in true}\n                            (and (not elide-vars)\n                                 extra-meta)\n                            (merge extra-meta))\n                    ctx?))))\n\n(defn new-var\n  ([sym f] (new-var sym f nil false))\n  ([sym f ns] (new-var sym f ns false))\n  ([sym f ns ctx?] (new-var sym f ns ctx? nil))\n  ([sym f ns ctx? extra-meta]\n   (let [ctx? (or ctx? (true? ns))\n         ns (if (true? ns)\n              clojure-core-ns\n              (or ns clojure-core-ns))]\n     (assert (and (not (boolean? ns))\n                  (instance? sci.lang.Namespace ns)) sym)\n     (utils/new-var sym f (cond-> {:ns ns\n                                   :sci/built-in true}\n                            (and (not elide-vars)\n                                 extra-meta)\n                            (merge extra-meta))\n                    ctx?))))\n"]}