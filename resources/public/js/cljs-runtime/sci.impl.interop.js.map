{"version":3,"sources":["sci/impl/interop.cljc"],"mappings":"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","names":["sci.impl.interop/invoke-instance-field","obj","_target-class","field-name","sci.impl.interop/invoke-instance-method","ctx","bindings","method-name","args","_arg-count","temp__5806__auto__","method","p1__39455#","sci.impl.types/eval","js/Reflect.apply","js/Error","sci.impl.interop/get-static-field","class","field-name-sym","sci.impl.interop/fn-eval-allowed?","e39456","js/Function","_","sci.impl.interop/get-static-fields","cur","parts","i","sci.impl.interop/accessor-fn","sci.impl.interop/invoke-js-constructor*","constructor","js/Reflect.construct","p1__39457#","sci.impl.interop/invoke-static-method","p1__39458#","sci.impl.interop/fully-qualify-class","sym","cljs.core/deref","env","class->opts","or__5045__auto__","temp__5802__auto__","ns*","cljs.core/namespace","cljs.core/contains?","cljs.core.symbol","cljs.core/name","cljs.core.get","cnn","sci.impl.utils/current-ns-name","cljs.core.get_in","sci.impl.interop/resolve-class-opts","class-opts","imports","vec__39459","cljs.core.nth","v","cljs.core/find","temp__5804__auto__","sci.impl.interop/resolve-class"],"sourcesContent":["(ns sci.impl.interop\n  {:no-doc true}\n  #?(:clj (:import\n           [java.lang.reflect Field Modifier]\n           [sci.impl Reflector]))\n  (:require [sci.impl.types]\n            [sci.impl.utils :as utils]))\n\n;; see https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Reflector.java\n;; see invokeStaticMethod, getStaticField, etc.\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn invoke-instance-field\n  #?@(:cljs [[obj _target-class field-name]\n             ;; gobject/get didn't work here\n             (aget obj field-name)]\n      :clj\n      [[obj ^Class target-class method]\n       (let [^Field field (.getField target-class method)\n             mod (.getModifiers field)]\n         (if (and (not (Modifier/isStatic mod))\n                  (Modifier/isPublic mod))\n           (.get field obj)\n           (throw (ex-info (str \"Not found or accessible instance field: \" method) {}))))]))\n\n#?(:clj\n   (defn meth-cache [ctx ^Class class meth-name len fetch-fn k]\n     (let [cname (.getName class)\n           env (:env ctx)\n           meths (-> (deref env) k (get cname) (get meth-name) (get len))]\n       (or meths\n           (let [meths (fetch-fn)]\n             (swap! env assoc-in [k cname meth-name len] meths)\n             meths)))))\n\n(defn invoke-instance-method\n  #?@(:cljs [[ctx bindings obj _target-class method-name args _arg-count]\n             ;; gobject/get didn't work here\n             (if-some [method (aget obj method-name)]\n               ;; use Reflect rather than (.apply method ...), see https://github.com/babashka/nbb/issues/118\n               (let [args (.map args #(sci.impl.types/eval % ctx bindings))]\n                 (js/Reflect.apply method obj args))\n               (throw (js/Error. (str \"Could not find instance method: \" method-name))))]\n      :clj\n      [[ctx bindings obj ^Class target-class method ^objects args arg-count]\n       (let [methods\n             (meth-cache ctx target-class method arg-count #(Reflector/getMethods target-class arg-count method false) :instance-methods)]\n         (if (and (zero? arg-count) (.isEmpty ^java.util.List methods))\n           (invoke-instance-field obj target-class method)\n           (do (let [args-array (object-array arg-count)]\n                 (areduce args idx _ret nil\n                          (aset args-array idx (sci.impl.types/eval (aget args idx) ctx bindings)))\n                 ;; Note: I also tried caching the method that invokeMatchingMethod looks up, but retrieving it from the cache was actually more expensive than just doing the invocation!\n                 ;; See getMatchingMethod in Reflector\n                 (Reflector/invokeMatchingMethod method methods obj args-array)))))]))\n\n(defn get-static-field [^Class class field-name-sym]\n  #?(:clj (Reflector/getStaticField class (str field-name-sym))\n     :cljs (unchecked-get class field-name-sym)))\n\n#?(:cljs\n   (def fn-eval-allowed?\n     (try (do (js/Function. \"return 1\")\n              true)\n          (catch :default _ false))))\n\n#?(:cljs\n   (do\n     (defn get-static-fields [cur ^js parts]\n       (loop [cur cur\n              i 0]\n         (if (< i (.-length parts))\n           (recur (unchecked-get cur (aget parts i)) (inc i)) cur)))\n     (defn accessor-fn\n       \"TODO: use this to look up at runtime, rather than look up at compile time, for correct behavior wrt. issue 877\"\n       [^js parts]\n       (if fn-eval-allowed?\n         (js/Function. \"obj\" (str \"return obj.\" (.join parts \".\")))\n         (fn [obj]\n           (get-static-fields obj parts))))))\n\n#?(:cljs\n   (defn invoke-js-constructor* [ctx bindings constructor args]\n     (js/Reflect.construct constructor (.map args #(sci.impl.types/eval % ctx bindings)))))\n\n#?(:clj\n   (defn invoke-constructor #?(:clj [^Class class args]\n                               :cljs [constructor args])\n     (Reflector/invokeConstructor class (object-array args))))\n\n(defn invoke-static-method #?(:clj [ctx bindings ^Class class ^String method-name ^objects args len]\n                              :cljs [ctx bindings class method args])\n  #?(:clj\n     (let [args-array (object-array len)]\n       ;; [a idx ret init expr]\n       (areduce args idx _ret nil\n                (aset args-array idx (sci.impl.types/eval (aget args idx) ctx bindings)))\n       ;; List methods = getMethods(c, args.length, methodName, true);\n       ;; invokeMatchingMethod(methodName, methods, null, args)\n       (let [meths (meth-cache ctx class method-name len #(sci.impl.Reflector/getMethods class len method-name true) :static-methods)]\n         ;; Note: I also tried caching the method that invokeMatchingMethod looks up, but retrieving it from the cache was actually more expensive than just doing the invocation!\n         ;; See getMatchingMethod in Reflector\n         (sci.impl.Reflector/invokeMatchingMethod method-name meths nil args-array)))\n     :cljs (js/Reflect.apply method class (.map args #(sci.impl.types/eval % ctx bindings)))))\n\n(defn fully-qualify-class [ctx sym]\n  (let [env @(:env ctx)\n        class->opts (:class->opts env)]\n    (or #?(:clj (when (contains? class->opts sym) sym)\n           :cljs (if-let [ns* (namespace sym)]\n                   (when (identical? \"js\" ns*)\n                     (when (contains? class->opts (symbol (name sym)))\n                       sym))\n                   (when (contains? class->opts sym)\n                     sym)))\n        (or (get (:imports env) sym)\n            (let [cnn (utils/current-ns-name)]\n              (get-in env [:namespaces cnn :imports sym]))))))\n\n(defn resolve-class-opts [ctx sym]\n  (let [env @(:env ctx)\n        class->opts (:class->opts env)\n        class-opts (or #?(:clj (get class->opts sym)\n                          :cljs (if-let [ns* (namespace sym)]\n                                  (when (identical? \"js\" ns*)\n                                    (get class->opts (symbol (name sym))))\n                                  (get class->opts sym)))\n                       (let [cnn (utils/current-ns-name)\n                             imports (get-in env [:namespaces cnn :imports])]\n                         (if-let [[_ v] (find imports sym)]\n                           ;; finding a nil v means the object was unmapped\n                           (get class->opts v)\n                           (when-let [v (get-in env [:imports sym])]\n                             (get class->opts v)))))]\n    class-opts))\n\n(defn resolve-class [ctx sym]\n  (:class (resolve-class-opts ctx sym)))\n"]}