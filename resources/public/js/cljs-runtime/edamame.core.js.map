{"version":3,"sources":["edamame/core.cljc"],"mappings":"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","names":["var_args","G__38987","edamame.core/parse-string","js/Error","s","edamame.impl.parser/parse-string","opts","G__38991","edamame.core/parse-string-all","edamame.impl.parser/parse-string-all","edamame.core/reader","x","edamame.impl.parser/reader","edamame.core/source-reader","edamame.impl.parser/source-logging-reader","edamame.core/get-line-number","reader","edamame.impl.parser/get-line-number","edamame.core/get-column-number","edamame.impl.parser/get-column-number","edamame.core/normalize-opts","edamame.impl.parser/normalize-opts","G__39000","edamame.core/parse-next","edamame.core.parse_next","normalized-opts","cljs.tools.reader.reader-types/source-logging-reader?","buf","edamame.impl.parser/buf","v","edamame.impl.parser.parse_next","edamame.impl.parser/eof","or__5045__auto__","cljs.core.get","G__39003","edamame.core/parse-next+string","edamame.core.parse_next_PLUS_string","clojure.string/trim","cljs.core.ex_info","edamame.core/iobj?","obj","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta","edamame.core/parse-ns-form","ns-form","edamame.impl.ns-parser/parse-ns-form"],"sourcesContent":["(ns edamame.core\n  (:require\n   [clojure.tools.reader.reader-types :as rt]\n   [edamame.impl.parser :as p]\n   [clojure.string :as str]\n   [edamame.impl.ns-parser :as nsp]))\n\n(defn parse-string\n  \"Parses first EDN value from string.\n\n  Supported parsing options can be `true` for default behavior or a function\n  that is called on the form and returns a form in its place:\n\n  `:deref`: parse forms starting with `@`. If `true`, the resulting\n  expression will be parsed as `(deref expr)`.\n\n  `:fn`: parse function literals (`#(inc %)`). If `true`, will be parsed as `(fn [%1] (inc %))`.\n\n  `:quote`: parse quoted expression `'foo`. If `true`, will be parsed as `(quote foo)`.\n\n  `:read-eval`: parse read-eval (`=(+ 1 2 3)`). If `true`, the\n  resulting expression will be parsed as `(read-eval (+ 1 2 3))`.\n\n  `:regex`: parse regex literals (`#\\\"foo\\\"`). If `true`, defaults to\n  `re-pattern`.\n\n  `:var`: parse var literals (`#'foo`). If `true`, the resulting\n  expression will be parsed as `(var foo)`.\n\n  `:syntax-quote`: parse syntax-quote (`(+ 1 2 3)`). Symbols get\n  qualified using `:resolve-symbol` which defaults to `identity`:\n  ```clojure\n  (parse-string \\\"`x\\\" {:syntax-quote {:resolve-symbol #(symbol \\\"user\\\" (str %))}})\n  ;;=> (quote user/x)\n  ```\n  By default, also parses `unquote` and `unquote-splicing` literals,\n  resolving them accordingly.\n\n  `:unquote`: parse unquote (`~x`). Requires `:syntax-quote` to be set.\n  If `true` and not inside `syntax-quote`, defaults to `clojure.core/unquote`.\n\n  `:unquote-splicing`: parse unquote-splicing (`~@x`). Requires `:syntax-quote`\n  to be set. If `true` and not inside `syntax-quote`, defaults\n  to `clojure.core/unquote-splicing`.\n\n  `:all`: when `true`, the above options will be set to `true` unless\n  explicitly provided.\n\n  Supported options for processing reader conditionals:\n\n  `:read-cond`: - `:allow` to process reader conditionals, or\n                  `:preserve` to keep all branches\n  `:features`: - persistent set of feature keywords for reader conditionals (e.g. `#{:clj}`).\n\n  `:auto-resolve`: map of alias to namespace symbols for\n  auto-resolving keywords. Use `:current` as the alias for the current\n  namespace.\n\n  `:readers`: data readers.\n\n  `:postprocess`: a function that is called with a map containing\n  `:obj`, the read value, and `:loc`, the location metadata. This can\n  be used to handle objects that cannot carry metadata differently. If\n  this option is provided, attaching location metadata is not\n  automatically added to the object.\n\n  `:location?`: a predicate that is called with the parsed\n  object. Should return a truthy value to determine if location\n  information will be added.\n\n  `:uneval`: a function of a map with `:uneval` and `:next` to preserve `#_` expressions by combining them with next value.\n\n  Additional arguments to tools.reader may be passed with\n  `:tools.reader/opts`, like `:readers` for passing reader tag functions.\n  \"\n  ([s]\n   (p/parse-string s nil))\n  ([s opts]\n   (p/parse-string s opts)))\n\n(defn parse-string-all\n  \"Like `parse-string` but parses all values from string and returns them\n  in a vector.\"\n  ([s]\n   (p/parse-string-all s nil))\n  ([s opts]\n   (p/parse-string-all s opts)))\n\n(defn reader\n  \"Coerces x into indexing pushback-reader to be used with\n  parse-next. Accepts string or `java.io.Reader`\"\n  [x]\n  (p/reader x))\n\n(defn source-reader\n  \"Coerces x into source-logging-reader to be used with\n  parse-next. Accepts string or `java.io.Reader`\"\n  [x]\n  (p/source-logging-reader x))\n\n(defn get-line-number [reader]\n  (p/get-line-number reader))\n\n(defn get-column-number [reader]\n  (p/get-column-number reader))\n\n(defn normalize-opts\n  \"Expands `opts` into normalized opts, e.g. `:all true` is expanded\n  into explicit options.\"\n  [opts]\n  (p/normalize-opts opts))\n\n(defn parse-next\n  \"Parses next form from reader. Accepts same opts as `parse-string`,\n  but must be normalized with `normalize-opts` first.\"\n  ([reader] (parse-next reader (p/normalize-opts {})))\n  ([reader normalized-opts]\n   (when (rt/source-logging-reader? reader)\n     (let [^StringBuilder buf (p/buf reader)]\n       #?(:clj (.setLength buf 0)\n          :cljs (.clear buf))))\n   (let [v (p/parse-next normalized-opts reader)]\n     (if (identical? p/eof v)\n       (or (get normalized-opts :eof)\n           ::eof)\n       v))))\n\n(defn parse-next+string\n  \"Parses next form from reader. Accepts same opts as `parse-string`,\n  but must be normalized with `normalize-opts` first.\n  Returns read value + string read (whitespace-trimmed).\"\n  ([reader] (parse-next+string reader (p/normalize-opts {})))\n  ([reader normalized-opts]\n   (if (rt/source-logging-reader? reader)\n     (let [v (parse-next reader normalized-opts)\n           s (str/trim (str (p/buf reader)))]\n       [v s])\n     (throw (ex-info \"parse-next+string must be called with source-reader\" {})))))\n\n(defn iobj?\n  \"Returns true if obj can carry metadata.\"\n  [obj]\n  #?(:clj\n     (instance? clojure.lang.IObj obj)\n     :cljs (satisfies? IWithMeta obj)))\n\n(defn parse-ns-form\n  \"Parses `ns-form`, an s-expression, into map with:\n  - `:name`: the name of the namespace\n  - `:aliases`: a map of aliases to lib names\"\n  [ns-form]\n  (nsp/parse-ns-form ns-form))\n\n;;;; Scratch\n\n(comment\n  (parse-string \"(1 2 3 #_4)\"))\n"]}