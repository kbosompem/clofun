{"version":3,"sources":["edamame/impl/ns_parser.cljc"],"mappings":"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","names":["edamame.impl.ns-parser/libspec?","x","cljs.core/Symbol","cljs.core/vector?","cljs.core/second","cljs.core/Keyword","edamame.impl.ns-parser/prependss","coll","cljs.core/cons","cljs.core.concat","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","edamame.impl.ns-parser/load-lib","seq37306","G__37307","cljs.core/first","cljs.core/next","G__37308","self__5754__auto__","prefix","lib","options","cljs.core.symbol","opts","cljs.core.apply","cljs.core/hash-map","cljs.core.assoc","edamame.impl.ns-parser/load-libs","kw","args","args*","flags","cljs.core.filter","cljs.core/keyword?","cljs.core.interleave","cljs.core.repeat","cljs.core/complement","cljs.core.mapcat","arg","vec__37309","seq__37310","cljs.core/seq","first__37311","cljs.core.ex_info","p__37315","vec__37316","seq__37317","first__37318","edamame.impl.ns-parser/-ns","_ns","name","references","docstring","cljs.core.vary_meta","cljs.core/assoc","metadata","cljs.core/map?","cljs.core/seq?","cljs.core/group-by","requires","p1__37312#","cljs.core/rest","cljs.core.reduce","acc","require","temp__5802__auto__","alias","or__5045__auto__","edamame.impl.ns-parser/parse-ns-form","ns-form"],"sourcesContent":["(ns edamame.impl.ns-parser)\n\n(defn- libspec?\n  \"Returns true if x is a libspec\"\n  [x]\n  (or (symbol? x)\n      (and (vector? x)\n           (or\n            (nil? (second x))\n            (keyword? (second x))))))\n\n(defn- prependss\n  \"Prepends a symbol or a seq to coll\"\n  [x coll]\n  (if (symbol? x)\n    (cons x coll)\n    (concat x coll)))\n\n(defn- load-lib\n  [prefix lib & options]\n  (let [lib (if prefix (symbol (str prefix \\. lib)) lib)\n        opts (apply hash-map options)]\n    (assoc opts :lib lib)))\n\n(defn- load-libs\n  [kw args]\n  (let [args* (cons kw args)\n        flags (filter keyword? args*)\n        opts (interleave flags (repeat true))\n        args* (filter (complement keyword?) args*)]\n    (mapcat (fn [arg]\n              (if (libspec? arg)\n                [(apply load-lib nil (prependss arg opts))]\n                (let [[prefix & args*] arg]\n                  (when (nil? prefix)\n                    (throw (ex-info \"prefix cannot be nil\"\n                                    {:args args})))\n                  (mapcat (fn [arg]\n                            [(apply load-lib prefix (prependss arg opts))])\n                          args*))))\n            args*)))\n\n(defn- -ns\n  [[_ns name & references]]\n  (let [docstring  (when (string? (first references)) (first references))\n        references (if docstring (next references) references)\n        name (if docstring\n               (vary-meta name assoc :doc docstring)\n               name)\n        metadata   (when (map? (first references)) (first references))\n        references (if metadata (next references) references)\n        references (filter seq? references)\n        references (group-by first references)\n        requires (mapcat #(load-libs :require (rest %)) (:require references))]\n    ;;(println exp)\n    {:current name\n     :meta metadata\n     :requires requires\n     :aliases (reduce (fn [acc require]\n                        (if-let [alias (or (:as require)\n                                           (:as-alias require))\n                                 ]\n                          (assoc acc alias (:lib require))\n                          acc))\n                      {}\n                      requires)}))\n\n(defn parse-ns-form [ns-form]\n  (-ns ns-form))\n\n;;;; Scratch\n\n(comment\n  (load-libs :require '[[foo.bar :as bar]])\n  (load-libs :require '[[foo [bar :as bar]]])\n  (parse-ns-form '(ns foo (:require [foo :as dude])))\n\n  )\n\n"]}