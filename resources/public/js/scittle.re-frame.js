SHADOW_ENV.evalLoad("re_frame.interop.js", true , "goog.provide(\x27re_frame.interop\x27);\nre_frame.interop.on_load \x3d (function re_frame$interop$on_load(listener){\ntry{return goog.events.listen(self,\x22load\x22,listener);\n}catch (e49251){var _ \x3d e49251;\nreturn null;\n}});\nre_frame.interop.next_tick \x3d goog.async.nextTick;\nre_frame.interop.empty_queue \x3d cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentQueue.EMPTY,cljs.core.PersistentVector.EMPTY);\nre_frame.interop.after_render \x3d reagent.core.after_render;\n/**\n * @define {boolean}\n */\nre_frame.interop.debug_enabled_QMARK_ \x3d goog.DEBUG;\nre_frame.interop.ratom \x3d (function re_frame$interop$ratom(x){\nreturn reagent.core.atom.cljs$core$IFn$_invoke$arity$1(x);\n});\nre_frame.interop.ratom_QMARK_ \x3d (function re_frame$interop$ratom_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.reagent$ratom$IReactiveAtom$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(reagent.ratom.IReactiveAtom,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(reagent.ratom.IReactiveAtom,x);\n}\n});\nre_frame.interop.deref_QMARK_ \x3d (function re_frame$interop$deref_QMARK_(x){\nif((!((x \x3d\x3d null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ \x26 (32768))) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d x.cljs$core$IDeref$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IDeref,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IDeref,x);\n}\n});\nre_frame.interop.make_reaction \x3d (function re_frame$interop$make_reaction(f){\nreturn reagent.ratom.make_reaction(f);\n});\nre_frame.interop.add_on_dispose_BANG_ \x3d (function re_frame$interop$add_on_dispose_BANG_(a_ratom,f){\nreturn reagent.ratom.add_on_dispose_BANG_(a_ratom,f);\n});\nre_frame.interop.dispose_BANG_ \x3d (function re_frame$interop$dispose_BANG_(a_ratom){\nreturn reagent.ratom.dispose_BANG_(a_ratom);\n});\nre_frame.interop.set_timeout_BANG_ \x3d (function re_frame$interop$set_timeout_BANG_(f,ms){\nreturn setTimeout(f,ms);\n});\nre_frame.interop.now \x3d (function re_frame$interop$now(){\nif((((typeof performance !\x3d\x3d \x27undefined\x27)) \x26\x26 ((typeof performance !\x3d\x3d \x27undefined\x27) \x26\x26 (typeof performance.now !\x3d\x3d \x27undefined\x27)))){\nreturn performance.now();\n} else {\nreturn Date.now();\n}\n});\n/**\n * Produces an id for reactive Reagent values\n *   e.g. reactions, ratoms, cursors.\n */\nre_frame.interop.reagent_id \x3d (function re_frame$interop$reagent_id(reactive_val){\nif((((!((reactive_val \x3d\x3d null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL \x3d\x3d\x3d reactive_val.reagent$ratom$IReactiveAtom$))))?true:false):false)){\nreturn [(function (){var pred__49266 \x3d cljs.core.instance_QMARK_;\nvar expr__49267 \x3d reactive_val;\nif(cljs.core.truth_((pred__49266.cljs$core$IFn$_invoke$arity$2 ? pred__49266.cljs$core$IFn$_invoke$arity$2(reagent.ratom.RAtom,expr__49267) : pred__49266.call(null,reagent.ratom.RAtom,expr__49267)))){\nreturn \x22ra\x22;\n} else {\nif(cljs.core.truth_((pred__49266.cljs$core$IFn$_invoke$arity$2 ? pred__49266.cljs$core$IFn$_invoke$arity$2(reagent.ratom.RCursor,expr__49267) : pred__49266.call(null,reagent.ratom.RCursor,expr__49267)))){\nreturn \x22rc\x22;\n} else {\nif(cljs.core.truth_((pred__49266.cljs$core$IFn$_invoke$arity$2 ? pred__49266.cljs$core$IFn$_invoke$arity$2(reagent.ratom.Reaction,expr__49267) : pred__49266.call(null,reagent.ratom.Reaction,expr__49267)))){\nreturn \x22rx\x22;\n} else {\nif(cljs.core.truth_((pred__49266.cljs$core$IFn$_invoke$arity$2 ? pred__49266.cljs$core$IFn$_invoke$arity$2(reagent.ratom.Track,expr__49267) : pred__49266.call(null,reagent.ratom.Track,expr__49267)))){\nreturn \x22tr\x22;\n} else {\nreturn \x22other\x22;\n}\n}\n}\n}\n})(),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.hash(reactive_val))].join(\x27\x27);\n} else {\nreturn null;\n}\n});\nre_frame.interop.reactive_QMARK_ \x3d (function re_frame$interop$reactive_QMARK_(){\nreturn reagent.ratom.reactive_QMARK_();\n});\n");
SHADOW_ENV.evalLoad("re_frame.db.js", true , "goog.provide(\x27re_frame.db\x27);\nre_frame.db.app_db \x3d re_frame.interop.ratom(cljs.core.PersistentArrayMap.EMPTY);\n");
SHADOW_ENV.evalLoad("re_frame.loggers.js", true , "goog.provide(\x27re_frame.loggers\x27);\n/**\n * Holds the current set of logging functions.\n * By default, re-frame uses the functions provided by js/console.\n * Use `set-loggers!` to change these defaults\n *   \n */\nre_frame.loggers.loggers \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22log\x22,\x22log\x22,-1595516004),console.log.bind(console),new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),console.warn.bind(console),new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),console.error.bind(console),new cljs.core.Keyword(null,\x22debug\x22,\x22debug\x22,-1608172596),console.debug.bind(console),new cljs.core.Keyword(null,\x22group\x22,\x22group\x22,582596132),(cljs.core.truth_(console.group)?console.group.bind(console):console.log.bind(console)),new cljs.core.Keyword(null,\x22groupEnd\x22,\x22groupEnd\x22,-337721382),(cljs.core.truth_(console.groupEnd)?console.groupEnd.bind(console):(function (){\nreturn cljs.core.List.EMPTY;\n}))], null));\nre_frame.loggers.console \x3d (function re_frame$loggers$console(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___49062 \x3d arguments.length;\nvar i__5770__auto___49063 \x3d (0);\nwhile(true){\nif((i__5770__auto___49063 \x3c len__5769__auto___49062)){\nargs__5775__auto__.push((arguments[i__5770__auto___49063]));\n\nvar G__49064 \x3d (i__5770__auto___49063 + (1));\ni__5770__auto___49063 \x3d G__49064;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((1) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((1)),(0),null)):null);\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5776__auto__);\n});\n\n(re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic \x3d (function (level,args){\nif(cljs.core.contains_QMARK_(cljs.core.deref(re_frame.loggers.loggers),level)){\n} else {\nthrow (new Error([\x22Assert failed: \x22,[\x22re-frame: log called with unknown level: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(level)].join(\x27\x27),\x22\\n\x22,\x22(contains? (clojure.core/deref loggers) level)\x22].join(\x27\x27)));\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2((function (){var G__49061 \x3d cljs.core.deref(re_frame.loggers.loggers);\nreturn (level.cljs$core$IFn$_invoke$arity$1 ? level.cljs$core$IFn$_invoke$arity$1(G__49061) : level.call(null,G__49061));\n})(),args);\n}));\n\n(re_frame.loggers.console.cljs$lang$maxFixedArity \x3d (1));\n\n/** @this {Function} */\n(re_frame.loggers.console.cljs$lang$applyTo \x3d (function (seq49056){\nvar G__49057 \x3d cljs.core.first(seq49056);\nvar seq49056__$1 \x3d cljs.core.next(seq49056);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__49057,seq49056__$1);\n}));\n\nre_frame.loggers.set_loggers_BANG_ \x3d (function re_frame$loggers$set_loggers_BANG_(new_loggers){\nif(cljs.core.empty_QMARK_(clojure.set.difference.cljs$core$IFn$_invoke$arity$2(cljs.core.set(cljs.core.keys(new_loggers)),cljs.core.set(cljs.core.keys(cljs.core.deref(re_frame.loggers.loggers)))))){\n} else {\nthrow (new Error([\x22Assert failed: \x22,\x22Unknown keys in new-loggers\x22,\x22\\n\x22,\x22(empty? (difference (set (keys new-loggers)) (-\x3e (clojure.core/deref loggers) keys set)))\x22].join(\x27\x27)));\n}\n\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.loggers.loggers,cljs.core.merge,new_loggers);\n});\n/**\n * Get the current logging functions used by re-frame.\n */\nre_frame.loggers.get_loggers \x3d (function re_frame$loggers$get_loggers(){\nreturn cljs.core.deref(re_frame.loggers.loggers);\n});\n");
SHADOW_ENV.evalLoad("re_frame.utils.js", true , "goog.provide(\x27re_frame.utils\x27);\n/**\n * Dissociates an entry from a nested associative structure returning a new\n *   nested structure. keys is a sequence of keys. Any empty maps that result\n *   will not be present in the new structure.\n *   The key thing is that \x27m\x27 remains identical? to itself if the path was never present\n */\nre_frame.utils.dissoc_in \x3d (function re_frame$utils$dissoc_in(m,p__49130){\nvar vec__49132 \x3d p__49130;\nvar seq__49133 \x3d cljs.core.seq(vec__49132);\nvar first__49134 \x3d cljs.core.first(seq__49133);\nvar seq__49133__$1 \x3d cljs.core.next(seq__49133);\nvar k \x3d first__49134;\nvar ks \x3d seq__49133__$1;\nvar keys \x3d vec__49132;\nif(ks){\nvar temp__5802__auto__ \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar nextmap \x3d temp__5802__auto__;\nvar newmap \x3d (re_frame.utils.dissoc_in.cljs$core$IFn$_invoke$arity$2 ? re_frame.utils.dissoc_in.cljs$core$IFn$_invoke$arity$2(nextmap,ks) : re_frame.utils.dissoc_in.call(null,nextmap,ks));\nif(cljs.core.seq(newmap)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,newmap);\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,k);\n}\n} else {\nreturn m;\n}\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,k);\n}\n});\nre_frame.utils.first_in_vector \x3d (function re_frame$utils$first_in_vector(v){\nif(cljs.core.vector_QMARK_(v)){\nreturn cljs.core.first(v);\n} else {\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: expected a vector, but got:\x22,v], 0));\n}\n});\n/**\n * Like apply, but f takes keyword arguments and the last argument is\n *   not a seq but a map with the arguments for f\n */\nre_frame.utils.apply_kw \x3d (function re_frame$utils$apply_kw(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___49145 \x3d arguments.length;\nvar i__5770__auto___49146 \x3d (0);\nwhile(true){\nif((i__5770__auto___49146 \x3c len__5769__auto___49145)){\nargs__5775__auto__.push((arguments[i__5770__auto___49146]));\n\nvar G__49147 \x3d (i__5770__auto___49146 + (1));\ni__5770__auto___49146 \x3d G__49147;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((1) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((1)),(0),null)):null);\nreturn re_frame.utils.apply_kw.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5776__auto__);\n});\n\n(re_frame.utils.apply_kw.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,args){\nif(cljs.core.map_QMARK_(cljs.core.last(args))){\n} else {\nthrow (new Error(\x22Assert failed: (map? (last args))\x22));\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.concat,cljs.core.butlast(args),cljs.core.last(args)));\n}));\n\n(re_frame.utils.apply_kw.cljs$lang$maxFixedArity \x3d (1));\n\n/** @this {Function} */\n(re_frame.utils.apply_kw.cljs$lang$applyTo \x3d (function (seq49138){\nvar G__49139 \x3d cljs.core.first(seq49138);\nvar seq49138__$1 \x3d cljs.core.next(seq49138);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__49139,seq49138__$1);\n}));\n\n");
SHADOW_ENV.evalLoad("re_frame.settings.js", true , "goog.provide(\x27re_frame.settings\x27);\nre_frame.settings.defaults \x3d new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22loaded?\x22,\x22loaded?\x22,-1108015206),false,new cljs.core.Keyword(null,\x22global-interceptors\x22,\x22global-interceptors\x22,-1995759472),re_frame.interop.empty_queue], null);\nre_frame.settings.store \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(re_frame.settings.defaults);\nre_frame.interop.on_load((function (){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(re_frame.settings.store,(function (m){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,new cljs.core.Keyword(null,\x22loaded?\x22,\x22loaded?\x22,-1108015206),true);\n}));\n}));\nre_frame.settings.loaded_QMARK_ \x3d (function re_frame$settings$loaded_QMARK_(){\nreturn new cljs.core.Keyword(null,\x22loaded?\x22,\x22loaded?\x22,-1108015206).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(re_frame.settings.store));\n});\nre_frame.settings._replace_global_interceptor \x3d (function re_frame$settings$_replace_global_interceptor(global_interceptors,interceptor){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (ret,existing_interceptor){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092).cljs$core$IFn$_invoke$arity$1(interceptor),new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092).cljs$core$IFn$_invoke$arity$1(existing_interceptor))){\nif(re_frame.interop.debug_enabled_QMARK_){\nif(cljs.core.not(re_frame.settings.loaded_QMARK_())){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: replacing duplicate global interceptor id: \x22,new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092).cljs$core$IFn$_invoke$arity$1(interceptor)], 0));\n} else {\n}\n} else {\n}\n\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ret,interceptor);\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ret,existing_interceptor);\n}\n}),re_frame.interop.empty_queue,global_interceptors);\n});\nre_frame.settings.reg_global_interceptor \x3d (function re_frame$settings$reg_global_interceptor(p__49269){\nvar map__49270 \x3d p__49269;\nvar map__49270__$1 \x3d cljs.core.__destructure_map(map__49270);\nvar interceptor \x3d map__49270__$1;\nvar id \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49270__$1,new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092));\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(re_frame.settings.store,cljs.core.update,new cljs.core.Keyword(null,\x22global-interceptors\x22,\x22global-interceptors\x22,-1995759472),(function (global_interceptors){\nvar ids \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),global_interceptors);\nif(cljs.core.truth_(cljs.core.some(cljs.core.PersistentHashSet.createAsIfByAssoc([id]),ids))){\nreturn re_frame.settings._replace_global_interceptor(global_interceptors,interceptor);\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(global_interceptors,interceptor);\n}\n}));\n});\nre_frame.settings.get_global_interceptors \x3d (function re_frame$settings$get_global_interceptors(){\nreturn new cljs.core.Keyword(null,\x22global-interceptors\x22,\x22global-interceptors\x22,-1995759472).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(re_frame.settings.store));\n});\nre_frame.settings.clear_global_interceptors \x3d (function re_frame$settings$clear_global_interceptors(var_args){\nvar G__49273 \x3d arguments.length;\nswitch (G__49273) {\ncase 0:\nreturn re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(re_frame.settings.store,cljs.core.assoc,new cljs.core.Keyword(null,\x22global-interceptors\x22,\x22global-interceptors\x22,-1995759472),re_frame.interop.empty_queue);\n}));\n\n(re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(re_frame.settings.store,cljs.core.update,new cljs.core.Keyword(null,\x22global-interceptors\x22,\x22global-interceptors\x22,-1995759472),(function (global_interceptors){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(re_frame.interop.empty_queue,cljs.core.remove.cljs$core$IFn$_invoke$arity$2((function (p1__49271_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(id,new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092).cljs$core$IFn$_invoke$arity$1(p1__49271_SHARP_));\n}),global_interceptors));\n}));\n}));\n\n(re_frame.settings.clear_global_interceptors.cljs$lang$maxFixedArity \x3d 1);\n\n");
SHADOW_ENV.evalLoad("re_frame.registrar.js", true , "goog.provide(\x27re_frame.registrar\x27);\nre_frame.registrar.kinds \x3d new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\x22sub\x22,\x22sub\x22,-2093760025),null,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),null,new cljs.core.Keyword(null,\x22cofx\x22,\x22cofx\x22,2013202907),null,new cljs.core.Keyword(null,\x22fx\x22,\x22fx\x22,-1237829572),null], null), null);\nre_frame.registrar.kind__GT_id__GT_handler \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nre_frame.registrar.get_handler \x3d (function re_frame$registrar$get_handler(var_args){\nvar G__49785 \x3d arguments.length;\nswitch (G__49785) {\ncase 1:\nreturn re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$1 \x3d (function (kind){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(re_frame.registrar.kind__GT_id__GT_handler),kind);\n}));\n\n(re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2 \x3d (function (kind,id){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(re_frame.registrar.kind__GT_id__GT_handler),kind),id);\n}));\n\n(re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3 \x3d (function (kind,id,required_QMARK_){\nvar handler \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(kind,id);\nif(re_frame.interop.debug_enabled_QMARK_){\nif(cljs.core.truth_((function (){var and__5043__auto__ \x3d required_QMARK_;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn (handler \x3d\x3d null);\n} else {\nreturn and__5043__auto__;\n}\n})())){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: no\x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(kind),\x22handler registered for:\x22,id], 0));\n} else {\n}\n} else {\n}\n\nreturn handler;\n}));\n\n(re_frame.registrar.get_handler.cljs$lang$maxFixedArity \x3d 3);\n\nre_frame.registrar.register_handler \x3d (function re_frame$registrar$register_handler(kind,id,handler_fn){\nif(re_frame.interop.debug_enabled_QMARK_){\nif(cljs.core.truth_((function (){var and__5043__auto__ \x3d cljs.core.not(re_frame.settings.loaded_QMARK_());\nif(and__5043__auto__){\nreturn re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(kind,id,false);\n} else {\nreturn and__5043__auto__;\n}\n})())){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: overwriting\x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(kind),\x22handler for:\x22,id], 0));\n} else {\n}\n} else {\n}\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(re_frame.registrar.kind__GT_id__GT_handler,cljs.core.assoc_in,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [kind,id], null),handler_fn);\n\nreturn handler_fn;\n});\nre_frame.registrar.clear_handlers \x3d (function re_frame$registrar$clear_handlers(var_args){\nvar G__49789 \x3d arguments.length;\nswitch (G__49789) {\ncase 0:\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn cljs.core.reset_BANG_(re_frame.registrar.kind__GT_id__GT_handler,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1 \x3d (function (kind){\nif(cljs.core.truth_((re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1 ? re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1(kind) : re_frame.registrar.kinds.call(null,kind)))){\n} else {\nthrow (new Error(\x22Assert failed: (kinds kind)\x22));\n}\n\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.registrar.kind__GT_id__GT_handler,cljs.core.dissoc,kind);\n}));\n\n(re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2 \x3d (function (kind,id){\nif(cljs.core.truth_((re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1 ? re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1(kind) : re_frame.registrar.kinds.call(null,kind)))){\n} else {\nthrow (new Error(\x22Assert failed: (kinds kind)\x22));\n}\n\nif(cljs.core.truth_(re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(kind,id))){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic(re_frame.registrar.kind__GT_id__GT_handler,cljs.core.update_in,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [kind], null),cljs.core.dissoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([id], 0));\n} else {\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: can\x27t clear\x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(kind),\x22handler for\x22,[cljs.core.str.cljs$core$IFn$_invoke$arity$1(id),\x22. Handler not found.\x22].join(\x27\x27)], 0));\n}\n}));\n\n(re_frame.registrar.clear_handlers.cljs$lang$maxFixedArity \x3d 2);\n\n");
SHADOW_ENV.evalLoad("re_frame.trace.js", true , "goog.provide(\x27re_frame.trace\x27);\nre_frame.trace.id \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\nre_frame.trace._STAR_current_trace_STAR_ \x3d null;\nre_frame.trace.reset_tracing_BANG_ \x3d (function re_frame$trace$reset_tracing_BANG_(){\nreturn cljs.core.reset_BANG_(re_frame.trace.id,(0));\n});\n/**\n * @define {boolean}\n */\nre_frame.trace.trace_enabled_QMARK_ \x3d goog.define(\x22re_frame.trace.trace_enabled_QMARK_\x22,false);\n/**\n * See https://groups.google.com/d/msg/clojurescript/jk43kmYiMhA/IHglVr_TPdgJ for more details\n */\nre_frame.trace.is_trace_enabled_QMARK_ \x3d (function re_frame$trace$is_trace_enabled_QMARK_(){\nreturn re_frame.trace.trace_enabled_QMARK_;\n});\nre_frame.trace.trace_cbs \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nif((typeof re_frame !\x3d\x3d \x27undefined\x27) \x26\x26 (typeof re_frame.trace !\x3d\x3d \x27undefined\x27) \x26\x26 (typeof re_frame.trace.traces !\x3d\x3d \x27undefined\x27)){\n} else {\nre_frame.trace.traces \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentVector.EMPTY);\n}\nif((typeof re_frame !\x3d\x3d \x27undefined\x27) \x26\x26 (typeof re_frame.trace !\x3d\x3d \x27undefined\x27) \x26\x26 (typeof re_frame.trace.next_delivery !\x3d\x3d \x27undefined\x27)){\n} else {\nre_frame.trace.next_delivery \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\n}\n/**\n * Registers a tracing callback function which will receive a collection of one or more traces.\n *   Will replace an existing callback function if it shares the same key.\n */\nre_frame.trace.register_trace_cb \x3d (function re_frame$trace$register_trace_cb(key,f){\nif(re_frame.trace.trace_enabled_QMARK_){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(re_frame.trace.trace_cbs,cljs.core.assoc,key,f);\n} else {\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22Tracing is not enabled. Please set {\\\x22re_frame.trace.trace_enabled_QMARK_\\\x22 true} in :closure-defines. See: https://github.com/day8/re-frame-10x#installation.\x22], 0));\n}\n});\nre_frame.trace.remove_trace_cb \x3d (function re_frame$trace$remove_trace_cb(key){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.trace_cbs,cljs.core.dissoc,key);\n\nreturn null;\n});\nre_frame.trace.next_id \x3d (function re_frame$trace$next_id(){\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(re_frame.trace.id,cljs.core.inc);\n});\nre_frame.trace.start_trace \x3d (function re_frame$trace$start_trace(p__49786){\nvar map__49787 \x3d p__49786;\nvar map__49787__$1 \x3d cljs.core.__destructure_map(map__49787);\nvar operation \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49787__$1,new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310));\nvar op_type \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49787__$1,new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668));\nvar tags \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49787__$1,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977));\nvar child_of \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49787__$1,new cljs.core.Keyword(null,\x22child-of\x22,\x22child-of\x22,-903376662));\nreturn new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),re_frame.trace.next_id(),new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),operation,new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),op_type,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),tags,new cljs.core.Keyword(null,\x22child-of\x22,\x22child-of\x22,-903376662),(function (){var or__5045__auto__ \x3d child_of;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_);\n}\n})(),new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981),re_frame.interop.now()], null);\n});\nre_frame.trace.debounce_time \x3d (50);\nre_frame.trace.debounce \x3d (function re_frame$trace$debounce(f,interval){\nreturn goog.functions.debounce(f,interval);\n});\nre_frame.trace.schedule_debounce \x3d re_frame.trace.debounce((function re_frame$trace$tracing_cb_debounced(){\nvar seq__49790_49826 \x3d cljs.core.seq(cljs.core.deref(re_frame.trace.trace_cbs));\nvar chunk__49791_49827 \x3d null;\nvar count__49792_49828 \x3d (0);\nvar i__49793_49829 \x3d (0);\nwhile(true){\nif((i__49793_49829 \x3c count__49792_49828)){\nvar vec__49806_49830 \x3d chunk__49791_49827.cljs$core$IIndexed$_nth$arity$2(null,i__49793_49829);\nvar k_49831 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49806_49830,(0),null);\nvar cb_49832 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49806_49830,(1),null);\ntry{var G__49810_49833 \x3d cljs.core.deref(re_frame.trace.traces);\n(cb_49832.cljs$core$IFn$_invoke$arity$1 ? cb_49832.cljs$core$IFn$_invoke$arity$1(G__49810_49833) : cb_49832.call(null,G__49810_49833));\n}catch (e49809){var e_49834 \x3d e49809;\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22Error thrown from trace cb\x22,k_49831,\x22while storing\x22,cljs.core.deref(re_frame.trace.traces),e_49834], 0));\n}\n\nvar G__49835 \x3d seq__49790_49826;\nvar G__49836 \x3d chunk__49791_49827;\nvar G__49837 \x3d count__49792_49828;\nvar G__49838 \x3d (i__49793_49829 + (1));\nseq__49790_49826 \x3d G__49835;\nchunk__49791_49827 \x3d G__49836;\ncount__49792_49828 \x3d G__49837;\ni__49793_49829 \x3d G__49838;\ncontinue;\n} else {\nvar temp__5804__auto___49839 \x3d cljs.core.seq(seq__49790_49826);\nif(temp__5804__auto___49839){\nvar seq__49790_49840__$1 \x3d temp__5804__auto___49839;\nif(cljs.core.chunked_seq_QMARK_(seq__49790_49840__$1)){\nvar c__5568__auto___49841 \x3d cljs.core.chunk_first(seq__49790_49840__$1);\nvar G__49842 \x3d cljs.core.chunk_rest(seq__49790_49840__$1);\nvar G__49843 \x3d c__5568__auto___49841;\nvar G__49844 \x3d cljs.core.count(c__5568__auto___49841);\nvar G__49845 \x3d (0);\nseq__49790_49826 \x3d G__49842;\nchunk__49791_49827 \x3d G__49843;\ncount__49792_49828 \x3d G__49844;\ni__49793_49829 \x3d G__49845;\ncontinue;\n} else {\nvar vec__49811_49846 \x3d cljs.core.first(seq__49790_49840__$1);\nvar k_49847 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49811_49846,(0),null);\nvar cb_49848 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49811_49846,(1),null);\ntry{var G__49815_49849 \x3d cljs.core.deref(re_frame.trace.traces);\n(cb_49848.cljs$core$IFn$_invoke$arity$1 ? cb_49848.cljs$core$IFn$_invoke$arity$1(G__49815_49849) : cb_49848.call(null,G__49815_49849));\n}catch (e49814){var e_49850 \x3d e49814;\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22Error thrown from trace cb\x22,k_49847,\x22while storing\x22,cljs.core.deref(re_frame.trace.traces),e_49850], 0));\n}\n\nvar G__49851 \x3d cljs.core.next(seq__49790_49840__$1);\nvar G__49852 \x3d null;\nvar G__49853 \x3d (0);\nvar G__49854 \x3d (0);\nseq__49790_49826 \x3d G__49851;\nchunk__49791_49827 \x3d G__49852;\ncount__49792_49828 \x3d G__49853;\ni__49793_49829 \x3d G__49854;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn cljs.core.reset_BANG_(re_frame.trace.traces,cljs.core.PersistentVector.EMPTY);\n}),re_frame.trace.debounce_time);\nre_frame.trace.run_tracing_callbacks_BANG_ \x3d (function re_frame$trace$run_tracing_callbacks_BANG_(now){\nif(((cljs.core.deref(re_frame.trace.next_delivery) - (25)) \x3c now)){\n(re_frame.trace.schedule_debounce.cljs$core$IFn$_invoke$arity$0 ? re_frame.trace.schedule_debounce.cljs$core$IFn$_invoke$arity$0() : re_frame.trace.schedule_debounce.call(null));\n\nreturn cljs.core.reset_BANG_(re_frame.trace.next_delivery,(now + re_frame.trace.debounce_time));\n} else {\nreturn null;\n}\n});\n");
SHADOW_ENV.evalLoad("re_frame.interceptor.js", true , "goog.provide(\x27re_frame.interceptor\x27);\nre_frame.interceptor.mandatory_interceptor_keys \x3d new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),null,new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),null,new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),null], null), null);\nre_frame.interceptor.interceptor_QMARK_ \x3d (function re_frame$interceptor$interceptor_QMARK_(m){\nreturn ((cljs.core.map_QMARK_(m)) \x26\x26 (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(re_frame.interceptor.mandatory_interceptor_keys,cljs.core.set(cljs.core.keys(m)))));\n});\nre_frame.interceptor.__GT_interceptor \x3d (function re_frame$interceptor$__GT_interceptor(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___49914 \x3d arguments.length;\nvar i__5770__auto___49915 \x3d (0);\nwhile(true){\nif((i__5770__auto___49915 \x3c len__5769__auto___49914)){\nargs__5775__auto__.push((arguments[i__5770__auto___49915]));\n\nvar G__49916 \x3d (i__5770__auto___49915 + (1));\ni__5770__auto___49915 \x3d G__49916;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((0) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic \x3d (function (p__49867){\nvar map__49868 \x3d p__49867;\nvar map__49868__$1 \x3d cljs.core.__destructure_map(map__49868);\nvar m \x3d map__49868__$1;\nvar id \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49868__$1,new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092));\nvar before \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49868__$1,new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388));\nvar after \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49868__$1,new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914));\nif(re_frame.interop.debug_enabled_QMARK_){\nvar temp__5802__auto___49918 \x3d cljs.core.seq(clojure.set.difference.cljs$core$IFn$_invoke$arity$2(cljs.core.set(cljs.core.keys(m)),re_frame.interceptor.mandatory_interceptor_keys));\nif(temp__5802__auto___49918){\nvar unknown_keys_49919 \x3d temp__5802__auto___49918;\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: -\x3einterceptor\x22,m,\x22has unknown keys:\x22,unknown_keys_49919], 0));\n} else {\n}\n} else {\n}\n\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),(function (){var or__5045__auto__ \x3d id;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\x22unnamed\x22,\x22unnamed\x22,-26044928);\n}\n})(),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),before,new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),after], null);\n}));\n\n(re_frame.interceptor.__GT_interceptor.cljs$lang$maxFixedArity \x3d (0));\n\n/** @this {Function} */\n(re_frame.interceptor.__GT_interceptor.cljs$lang$applyTo \x3d (function (seq49866){\nvar self__5755__auto__ \x3d this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq49866));\n}));\n\nre_frame.interceptor.get_effect \x3d (function re_frame$interceptor$get_effect(var_args){\nvar G__49870 \x3d arguments.length;\nswitch (G__49870) {\ncase 1:\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1 \x3d (function (context){\nreturn new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292).cljs$core$IFn$_invoke$arity$1(context);\n}));\n\n(re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2 \x3d (function (context,key){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),key], null));\n}));\n\n(re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$3 \x3d (function (context,key,not_found){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),key], null),not_found);\n}));\n\n(re_frame.interceptor.get_effect.cljs$lang$maxFixedArity \x3d 3);\n\nre_frame.interceptor.assoc_effect \x3d (function re_frame$interceptor$assoc_effect(context,key,value){\nreturn cljs.core.assoc_in(context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),key], null),value);\n});\nre_frame.interceptor.update_effect \x3d (function re_frame$interceptor$update_effect(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___49924 \x3d arguments.length;\nvar i__5770__auto___49925 \x3d (0);\nwhile(true){\nif((i__5770__auto___49925 \x3c len__5769__auto___49924)){\nargs__5775__auto__.push((arguments[i__5770__auto___49925]));\n\nvar G__49926 \x3d (i__5770__auto___49925 + (1));\ni__5770__auto___49925 \x3d G__49926;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((3) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((3)),(0),null)):null);\nreturn re_frame.interceptor.update_effect.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__5776__auto__);\n});\n\n(re_frame.interceptor.update_effect.cljs$core$IFn$_invoke$arity$variadic \x3d (function (context,key,f,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(cljs.core.update_in,context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),key], null),f,args);\n}));\n\n(re_frame.interceptor.update_effect.cljs$lang$maxFixedArity \x3d (3));\n\n/** @this {Function} */\n(re_frame.interceptor.update_effect.cljs$lang$applyTo \x3d (function (seq49872){\nvar G__49873 \x3d cljs.core.first(seq49872);\nvar seq49872__$1 \x3d cljs.core.next(seq49872);\nvar G__49874 \x3d cljs.core.first(seq49872__$1);\nvar seq49872__$2 \x3d cljs.core.next(seq49872__$1);\nvar G__49875 \x3d cljs.core.first(seq49872__$2);\nvar seq49872__$3 \x3d cljs.core.next(seq49872__$2);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__49873,G__49874,G__49875,seq49872__$3);\n}));\n\nre_frame.interceptor.get_coeffect \x3d (function re_frame$interceptor$get_coeffect(var_args){\nvar G__49878 \x3d arguments.length;\nswitch (G__49878) {\ncase 1:\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1 \x3d (function (context){\nreturn new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985).cljs$core$IFn$_invoke$arity$1(context);\n}));\n\n(re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2 \x3d (function (context,key){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),key], null));\n}));\n\n(re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$3 \x3d (function (context,key,not_found){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),key], null),not_found);\n}));\n\n(re_frame.interceptor.get_coeffect.cljs$lang$maxFixedArity \x3d 3);\n\nre_frame.interceptor.assoc_coeffect \x3d (function re_frame$interceptor$assoc_coeffect(context,key,value){\nreturn cljs.core.assoc_in(context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),key], null),value);\n});\nre_frame.interceptor.update_coeffect \x3d (function re_frame$interceptor$update_coeffect(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___49928 \x3d arguments.length;\nvar i__5770__auto___49929 \x3d (0);\nwhile(true){\nif((i__5770__auto___49929 \x3c len__5769__auto___49928)){\nargs__5775__auto__.push((arguments[i__5770__auto___49929]));\n\nvar G__49930 \x3d (i__5770__auto___49929 + (1));\ni__5770__auto___49929 \x3d G__49930;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((3) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((3)),(0),null)):null);\nreturn re_frame.interceptor.update_coeffect.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__5776__auto__);\n});\n\n(re_frame.interceptor.update_coeffect.cljs$core$IFn$_invoke$arity$variadic \x3d (function (context,key,f,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(cljs.core.update_in,context,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),key], null),f,args);\n}));\n\n(re_frame.interceptor.update_coeffect.cljs$lang$maxFixedArity \x3d (3));\n\n/** @this {Function} */\n(re_frame.interceptor.update_coeffect.cljs$lang$applyTo \x3d (function (seq49888){\nvar G__49889 \x3d cljs.core.first(seq49888);\nvar seq49888__$1 \x3d cljs.core.next(seq49888);\nvar G__49890 \x3d cljs.core.first(seq49888__$1);\nvar seq49888__$2 \x3d cljs.core.next(seq49888__$1);\nvar G__49891 \x3d cljs.core.first(seq49888__$2);\nvar seq49888__$3 \x3d cljs.core.next(seq49888__$2);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__49889,G__49890,G__49891,seq49888__$3);\n}));\n\nre_frame.interceptor.invoke_interceptor_fn \x3d (function re_frame$interceptor$invoke_interceptor_fn(context,interceptor,direction){\nvar temp__5802__auto__ \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(interceptor,direction);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar f \x3d temp__5802__auto__;\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(context) : f.call(null,context));\n} else {\nreturn context;\n}\n});\n/**\n * Loop over all interceptors, calling `direction` function on each,\n *   threading the value of `context` through every call.\n * \n *   `direction` is one of `:before` or `:after`.\n * \n *   Each iteration, the next interceptor to process is obtained from\n *   context\x27s `:queue`. After they are processed, interceptors are popped\n *   from `:queue` and added to `:stack`.\n * \n *   After sufficient iteration, `:queue` will be empty, and `:stack` will\n *   contain all interceptors processed.\n * \n *   Returns updated `context`. Ie. the `context` which has been threaded\n *   through all interceptor functions.\n * \n *   Generally speaking, an interceptor\x27s `:before` function will (if present)\n *   add to a `context\x27s` `:coeffects`, while its `:after` function\n *   will modify the `context`\x27s `:effects`.  Very approximately.\n * \n *   But because all interceptor functions are given `context`, and can\n *   return a modified version of it, the way is clear for an interceptor\n *   to introspect the stack or queue, or even modify the queue\n *   (add new interceptors via `enqueue`?). This is a very fluid arrangement.\n */\nre_frame.interceptor.invoke_interceptors \x3d (function re_frame$interceptor$invoke_interceptors(context,direction){\nvar context__$1 \x3d context;\nwhile(true){\nvar queue \x3d new cljs.core.Keyword(null,\x22queue\x22,\x22queue\x22,1455835879).cljs$core$IFn$_invoke$arity$1(context__$1);\nif(cljs.core.empty_QMARK_(queue)){\nreturn context__$1;\n} else {\nvar interceptor \x3d cljs.core.peek(queue);\nvar stack \x3d new cljs.core.Keyword(null,\x22stack\x22,\x22stack\x22,-793405930).cljs$core$IFn$_invoke$arity$1(context__$1);\nvar G__49933 \x3d re_frame.interceptor.invoke_interceptor_fn(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(context__$1,new cljs.core.Keyword(null,\x22queue\x22,\x22queue\x22,1455835879),cljs.core.pop(queue),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22stack\x22,\x22stack\x22,-793405930),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,interceptor)], 0)),interceptor,direction);\ncontext__$1 \x3d G__49933;\ncontinue;\n}\nbreak;\n}\n});\nre_frame.interceptor.enqueue \x3d (function re_frame$interceptor$enqueue(context,interceptors){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(context,new cljs.core.Keyword(null,\x22queue\x22,\x22queue\x22,1455835879),cljs.core.fnil.cljs$core$IFn$_invoke$arity$2(cljs.core.into,re_frame.interop.empty_queue),interceptors);\n});\n/**\n * Create a fresh context\n */\nre_frame.interceptor.context \x3d (function re_frame$interceptor$context(var_args){\nvar G__49900 \x3d arguments.length;\nswitch (G__49900) {\ncase 2:\nreturn re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$2 \x3d (function (event,interceptors){\nreturn re_frame.interceptor.enqueue(re_frame.interceptor.assoc_coeffect(re_frame.interceptor.assoc_coeffect(cljs.core.PersistentArrayMap.EMPTY,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),event),new cljs.core.Keyword(null,\x22original-event\x22,\x22original-event\x22,2121330403),event),interceptors);\n}));\n\n(re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$3 \x3d (function (event,interceptors,db){\nreturn re_frame.interceptor.assoc_coeffect(re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$2(event,interceptors),new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),db);\n}));\n\n(re_frame.interceptor.context.cljs$lang$maxFixedArity \x3d 3);\n\n/**\n * Called on completion of `:before` processing, this function prepares/modifies\n * `context` for the backwards sweep of processing in which an interceptor\n * chain\x27s `:after` fns are called.\n * \n *   At this point in processing, the `:queue` is empty and `:stack` holds all\n *   the previously run interceptors. So this function enables the backwards walk\n *   by priming `:queue` with what\x27s currently in `:stack`\n */\nre_frame.interceptor.change_direction \x3d (function re_frame$interceptor$change_direction(context){\nreturn re_frame.interceptor.enqueue(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22queue\x22,\x22queue\x22,1455835879)),new cljs.core.Keyword(null,\x22stack\x22,\x22stack\x22,-793405930).cljs$core$IFn$_invoke$arity$1(context));\n});\n/**\n * Executes the given chain (coll) of interceptors.\n * \n * Each interceptor has this form:\n *     {:before  (fn [context] ...)     ;; returns possibly modified context\n *      :after   (fn [context] ...)}    ;; `identity` would be a noop\n * \n * Walks the queue of interceptors from beginning to end, calling the\n * `:before` fn on each, then reverse direction and walk backwards,\n * calling the `:after` fn on each.\n * \n * The last interceptor in the chain presumably wraps an event\n * handler fn. So the overall goal of the process is to \x22handle\n * the given event\x22.\n * \n * Thread a `context` through all calls. `context` has this form:\n * \n *   {:coeffects {:event [:a-query-id :some-param]\n *                :db    \x3coriginal contents of app-db\x3e}\n *    :effects   {:db    \x3cnew value for app-db\x3e\n *                :fx  [:dispatch [:an-event-id :param1]]}\n *    :queue     \x3ca collection of further interceptors\x3e\n *    :stack     \x3ca collection of interceptors already walked\x3e}\n * \n * `context` has `:coeffects` and `:effects` which, if this was a web\n * server, would be somewhat analogous to `request` and `response`\n * respectively.\n * \n * `coeffects` will contain data like `event` and the initial\n * state of `db` -  the inputs required by the event handler\n * (sitting presumably on the end of the chain), while handler-returned\n * side effects are put into `:effects` including, but not limited to,\n * new values for `db`.\n * \n * The first few interceptors in a chain will likely have `:before`\n * functions which \x22prime\x22 the `context` by adding the event, and\n * the current state of app-db into `:coeffects`. But interceptors can\n * add whatever they want to `:coeffects` - perhaps the event handler needs\n * some information from localstore, or a random number, or access to\n * a DataScript connection.\n * \n * Equally, some interceptors in the chain will have `:after` fn\n * which can process the side effects accumulated into `:effects`\n * including but, not limited to, updates to app-db.\n * \n * Through both stages (before and after), `context` contains a `:queue`\n * of interceptors yet to be processed, and a `:stack` of interceptors\n * already done.  In advanced cases, these values can be modified by the\n * functions through which the context is threaded.\n */\nre_frame.interceptor.execute \x3d (function re_frame$interceptor$execute(event_v,interceptors){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49937 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22interceptors\x22,\x22interceptors\x22,-1546782951),interceptors], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22interceptors\x22,\x22interceptors\x22,-1546782951),interceptors], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49937);\n\n} else {\n}\n\nreturn re_frame.interceptor.invoke_interceptors(re_frame.interceptor.change_direction(re_frame.interceptor.invoke_interceptors(re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$2(event_v,interceptors),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388))),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914));\n});\n");
SHADOW_ENV.evalLoad("re_frame.events.js", true , "goog.provide(\x27re_frame.events\x27);\nre_frame.events.kind \x3d new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442);\nif(cljs.core.truth_((re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1 ? re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1(re_frame.events.kind) : re_frame.registrar.kinds.call(null,re_frame.events.kind)))){\n} else {\nthrow (new Error(\x22Assert failed: (re-frame.registrar/kinds kind)\x22));\n}\n/**\n * `interceptors` might have nested collections, and contain nil elements.\n *   return a flat collection, with all nils removed.\n *   This function is 9/10 about giving good error messages.\n */\nre_frame.events.flatten_and_remove_nils \x3d (function re_frame$events$flatten_and_remove_nils(id,interceptors){\nvar make_chain \x3d (function (p1__49942_SHARP_){\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,cljs.core.flatten(p1__49942_SHARP_));\n});\nif((!(re_frame.interop.debug_enabled_QMARK_))){\nreturn make_chain(interceptors);\n} else {\nif(cljs.core.coll_QMARK_(interceptors)){\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: when registering\x22,id,\x22, expected a collection of interceptors, got:\x22,interceptors], 0));\n}\n\nvar chain \x3d make_chain(interceptors);\nif(cljs.core.empty_QMARK_(chain)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: when registering\x22,id,\x22, given an empty interceptor chain\x22], 0));\n} else {\n}\n\nvar temp__5804__auto___50014 \x3d cljs.core.first(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(re_frame.interceptor.interceptor_QMARK_,chain));\nif(cljs.core.truth_(temp__5804__auto___50014)){\nvar not_i_50015 \x3d temp__5804__auto___50014;\nif(cljs.core.fn_QMARK_(not_i_50015)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: when registering\x22,id,\x22, got a function instead of an interceptor. Did you provide old style middleware by mistake? Got:\x22,not_i_50015], 0));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: when registering\x22,id,\x22, expected interceptors, but got:\x22,not_i_50015], 0));\n}\n} else {\n}\n\nreturn chain;\n}\n});\n/**\n * Associate the given event `id` with the given collection of `interceptors`.\n * \n * `interceptors` may contain nested collections and there may be nils\n * at any level,so process this structure into a simple, nil-less vector\n * before registration.\n * \n * Typically, an `event handler` will be at the end of the chain (wrapped\n * in an interceptor).\n */\nre_frame.events.register \x3d (function re_frame$events$register(id,interceptors){\nreturn re_frame.registrar.register_handler(re_frame.events.kind,id,re_frame.events.flatten_and_remove_nils(id,interceptors));\n});\nre_frame.events._STAR_handling_STAR_ \x3d null;\n/**\n * Given an event vector `event-v`, look up the associated interceptor chain, and execute it.\n */\nre_frame.events.handle \x3d (function re_frame$events$handle(event_v){\nvar event_id \x3d re_frame.utils.first_in_vector(event_v);\nvar temp__5802__auto__ \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.events.kind,event_id,true);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar interceptors \x3d temp__5802__auto__;\nif(cljs.core.truth_(re_frame.events._STAR_handling_STAR_)){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: while handling\x22,re_frame.events._STAR_handling_STAR_,\x22, dispatch-sync was called for\x22,event_v,\x22. You can\x27t call dispatch-sync within an event handler.\x22], 0));\n} else {\nvar _STAR_handling_STAR__orig_val__49951 \x3d re_frame.events._STAR_handling_STAR_;\nvar _STAR_handling_STAR__temp_val__49952 \x3d event_v;\n(re_frame.events._STAR_handling_STAR_ \x3d _STAR_handling_STAR__temp_val__49952);\n\ntry{if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__49965 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__49966 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),event_id,new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),re_frame.events.kind,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),event_v], null)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__49966);\n\ntry{try{if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50026 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-before\x22,\x22app-db-before\x22,-1442902645),cljs.core.deref(re_frame.db.app_db)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-before\x22,\x22app-db-before\x22,-1442902645),cljs.core.deref(re_frame.db.app_db)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50026);\n\n} else {\n}\n\nre_frame.interceptor.execute(event_v,interceptors);\n\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50027 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-after\x22,\x22app-db-after\x22,1477492964),cljs.core.deref(re_frame.db.app_db)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-after\x22,\x22app-db-after\x22,1477492964),cljs.core.deref(re_frame.db.app_db)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50027);\n\nreturn null;\n} else {\nreturn null;\n}\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50029 \x3d re_frame.interop.now();\nvar duration__49765__auto___50030 \x3d (end__49764__auto___50029 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50030,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50029);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__49965);\n}} else {\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50031 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-before\x22,\x22app-db-before\x22,-1442902645),cljs.core.deref(re_frame.db.app_db)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-before\x22,\x22app-db-before\x22,-1442902645),cljs.core.deref(re_frame.db.app_db)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50031);\n\n} else {\n}\n\nre_frame.interceptor.execute(event_v,interceptors);\n\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50036 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-after\x22,\x22app-db-after\x22,1477492964),cljs.core.deref(re_frame.db.app_db)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22app-db-after\x22,\x22app-db-after\x22,1477492964),cljs.core.deref(re_frame.db.app_db)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50036);\n\nreturn null;\n} else {\nreturn null;\n}\n}\n}finally {(re_frame.events._STAR_handling_STAR_ \x3d _STAR_handling_STAR__orig_val__49951);\n}}\n} else {\nreturn null;\n}\n});\n");
SHADOW_ENV.evalLoad("re_frame.subs.js", true , "goog.provide(\x27re_frame.subs\x27);\nre_frame.subs.kind \x3d new cljs.core.Keyword(null,\x22sub\x22,\x22sub\x22,-2093760025);\nif(cljs.core.truth_((re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1 ? re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1(re_frame.subs.kind) : re_frame.registrar.kinds.call(null,re_frame.subs.kind)))){\n} else {\nthrow (new Error(\x22Assert failed: (re-frame.registrar/kinds kind)\x22));\n}\nre_frame.subs.query__GT_reaction \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\n/**\n * calls `on-dispose` for each cached item, \n * which will cause the value to be removed from the cache\n */\nre_frame.subs.clear_subscription_cache_BANG_ \x3d (function re_frame$subs$clear_subscription_cache_BANG_(){\nvar seq__49819_49954 \x3d cljs.core.seq(cljs.core.deref(re_frame.subs.query__GT_reaction));\nvar chunk__49820_49955 \x3d null;\nvar count__49821_49956 \x3d (0);\nvar i__49822_49957 \x3d (0);\nwhile(true){\nif((i__49822_49957 \x3c count__49821_49956)){\nvar vec__49858_49958 \x3d chunk__49820_49955.cljs$core$IIndexed$_nth$arity$2(null,i__49822_49957);\nvar k_49959 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49858_49958,(0),null);\nvar rxn_49960 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49858_49958,(1),null);\nre_frame.interop.dispose_BANG_(rxn_49960);\n\n\nvar G__49961 \x3d seq__49819_49954;\nvar G__49962 \x3d chunk__49820_49955;\nvar G__49963 \x3d count__49821_49956;\nvar G__49964 \x3d (i__49822_49957 + (1));\nseq__49819_49954 \x3d G__49961;\nchunk__49820_49955 \x3d G__49962;\ncount__49821_49956 \x3d G__49963;\ni__49822_49957 \x3d G__49964;\ncontinue;\n} else {\nvar temp__5804__auto___49967 \x3d cljs.core.seq(seq__49819_49954);\nif(temp__5804__auto___49967){\nvar seq__49819_49968__$1 \x3d temp__5804__auto___49967;\nif(cljs.core.chunked_seq_QMARK_(seq__49819_49968__$1)){\nvar c__5568__auto___49969 \x3d cljs.core.chunk_first(seq__49819_49968__$1);\nvar G__49970 \x3d cljs.core.chunk_rest(seq__49819_49968__$1);\nvar G__49971 \x3d c__5568__auto___49969;\nvar G__49972 \x3d cljs.core.count(c__5568__auto___49969);\nvar G__49973 \x3d (0);\nseq__49819_49954 \x3d G__49970;\nchunk__49820_49955 \x3d G__49971;\ncount__49821_49956 \x3d G__49972;\ni__49822_49957 \x3d G__49973;\ncontinue;\n} else {\nvar vec__49861_49974 \x3d cljs.core.first(seq__49819_49968__$1);\nvar k_49975 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49861_49974,(0),null);\nvar rxn_49976 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49861_49974,(1),null);\nre_frame.interop.dispose_BANG_(rxn_49976);\n\n\nvar G__49977 \x3d cljs.core.next(seq__49819_49968__$1);\nvar G__49978 \x3d null;\nvar G__49979 \x3d (0);\nvar G__49980 \x3d (0);\nseq__49819_49954 \x3d G__49977;\nchunk__49820_49955 \x3d G__49978;\ncount__49821_49956 \x3d G__49979;\ni__49822_49957 \x3d G__49980;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nif(cljs.core.truth_(cljs.core.not_empty(cljs.core.deref(re_frame.subs.query__GT_reaction)))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: The subscription cache isn\x27t empty after being cleared\x22], 0));\n} else {\nreturn null;\n}\n});\n/**\n * Unregisters all existing subscription handlers\n */\nre_frame.subs.clear_all_handlers_BANG_ \x3d (function re_frame$subs$clear_all_handlers_BANG_(){\nre_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.subs.kind);\n\nreturn re_frame.subs.clear_subscription_cache_BANG_();\n});\n/**\n * cache the reaction r\n */\nre_frame.subs.cache_and_return \x3d (function re_frame$subs$cache_and_return(query_v,dynv,r){\nvar cache_key \x3d new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [query_v,dynv], null);\nre_frame.interop.add_on_dispose_BANG_(r,(function (){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__49864 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__49865 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.utils.first_in_vector(query_v),new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22sub\x22,\x22dispose\x22,\x22sub/dispose\x22,365440536),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22query-v\x22,\x22query-v\x22,-1514170131),query_v,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(r)], null)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__49865);\n\ntry{try{return cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(re_frame.subs.query__GT_reaction,(function (query_cache){\nif(((cljs.core.contains_QMARK_(query_cache,cache_key)) \x26\x26 ((r \x3d\x3d\x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(query_cache,cache_key))))){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(query_cache,cache_key);\n} else {\nreturn query_cache;\n}\n}));\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___49981 \x3d re_frame.interop.now();\nvar duration__49765__auto___49982 \x3d (end__49764__auto___49981 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___49982,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___49981);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__49864);\n}} else {\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(re_frame.subs.query__GT_reaction,(function (query_cache){\nif(((cljs.core.contains_QMARK_(query_cache,cache_key)) \x26\x26 ((r \x3d\x3d\x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(query_cache,cache_key))))){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(query_cache,cache_key);\n} else {\nreturn query_cache;\n}\n}));\n}\n}));\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(re_frame.subs.query__GT_reaction,(function (query_cache){\nif(re_frame.interop.debug_enabled_QMARK_){\nif(cljs.core.contains_QMARK_(query_cache,cache_key)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: Adding a new subscription to the cache while there is an existing subscription in the cache\x22,cache_key], 0));\n} else {\n}\n} else {\n}\n\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(query_cache,cache_key,r);\n}));\n\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49983 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(r)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(r)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49983);\n\n} else {\n}\n\nreturn r;\n});\nre_frame.subs.cache_lookup \x3d (function re_frame$subs$cache_lookup(var_args){\nvar G__49876 \x3d arguments.length;\nswitch (G__49876) {\ncase 1:\nreturn re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$1 \x3d (function (query_v){\nreturn re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$2(query_v,cljs.core.PersistentVector.EMPTY);\n}));\n\n(re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$2 \x3d (function (query_v,dyn_v){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(re_frame.subs.query__GT_reaction),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [query_v,dyn_v], null));\n}));\n\n(re_frame.subs.cache_lookup.cljs$lang$maxFixedArity \x3d 2);\n\nre_frame.subs.warn_when_not_reactive \x3d (function re_frame$subs$warn_when_not_reactive(){\nif(((re_frame.interop.debug_enabled_QMARK_) \x26\x26 ((!(re_frame.interop.reactive_QMARK_()))))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: Subscribe was called outside of a reactive context.\\n\x22,\x22See: https://day8.github.io/re-frame/FAQs/UseASubscriptionInAJsEvent/\\n\x22,\x22https://day8.github.io/re-frame/FAQs/UseASubscriptionInAnEventHandler/\x22], 0));\n} else {\nreturn null;\n}\n});\nre_frame.subs.subscribe \x3d (function re_frame$subs$subscribe(var_args){\nvar G__49880 \x3d arguments.length;\nswitch (G__49880) {\ncase 1:\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$1 \x3d (function (query){\nre_frame.subs.warn_when_not_reactive();\n\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__49881 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__49882 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.utils.first_in_vector(query),new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22sub\x22,\x22create\x22,\x22sub/create\x22,-1301317560),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22query-v\x22,\x22query-v\x22,-1514170131),query], null)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__49882);\n\ntry{try{var temp__5802__auto__ \x3d re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$1(query);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar cached \x3d temp__5802__auto__;\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49986 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49986);\n\n} else {\n}\n\nreturn cached;\n} else {\nvar query_id \x3d re_frame.utils.first_in_vector(query);\nvar handler_fn \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(re_frame.subs.kind,query_id);\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49987 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49987);\n\n} else {\n}\n\nif((handler_fn \x3d\x3d null)){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49988 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49988);\n\n} else {\n}\n\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([[\x22re-frame: no subscription handler registered for: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(query_id),\x22. Returning a nil subscription.\x22].join(\x27\x27)], 0));\n} else {\nreturn re_frame.subs.cache_and_return(query,cljs.core.PersistentVector.EMPTY,(handler_fn.cljs$core$IFn$_invoke$arity$2 ? handler_fn.cljs$core$IFn$_invoke$arity$2(re_frame.db.app_db,query) : handler_fn.call(null,re_frame.db.app_db,query)));\n}\n}\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___49989 \x3d re_frame.interop.now();\nvar duration__49765__auto___49990 \x3d (end__49764__auto___49989 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___49990,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___49989);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__49881);\n}} else {\nvar temp__5802__auto__ \x3d re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$1(query);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar cached \x3d temp__5802__auto__;\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49991 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49991);\n\n} else {\n}\n\nreturn cached;\n} else {\nvar query_id \x3d re_frame.utils.first_in_vector(query);\nvar handler_fn \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(re_frame.subs.kind,query_id);\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49992 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49992);\n\n} else {\n}\n\nif((handler_fn \x3d\x3d null)){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49993 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49993);\n\n} else {\n}\n\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([[\x22re-frame: no subscription handler registered for: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(query_id),\x22. Returning a nil subscription.\x22].join(\x27\x27)], 0));\n} else {\nreturn re_frame.subs.cache_and_return(query,cljs.core.PersistentVector.EMPTY,(handler_fn.cljs$core$IFn$_invoke$arity$2 ? handler_fn.cljs$core$IFn$_invoke$arity$2(re_frame.db.app_db,query) : handler_fn.call(null,re_frame.db.app_db,query)));\n}\n}\n}\n}));\n\n(re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$2 \x3d (function (query,dynv){\nre_frame.subs.warn_when_not_reactive();\n\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__49883 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__49884 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.utils.first_in_vector(query),new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22sub\x22,\x22create\x22,\x22sub/create\x22,-1301317560),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22query-v\x22,\x22query-v\x22,-1514170131),query,new cljs.core.Keyword(null,\x22dyn-v\x22,\x22dyn-v\x22,949994592),dynv], null)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__49884);\n\ntry{try{var temp__5802__auto__ \x3d re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$2(query,dynv);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar cached \x3d temp__5802__auto__;\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49997 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49997);\n\n} else {\n}\n\nreturn cached;\n} else {\nvar query_id \x3d re_frame.utils.first_in_vector(query);\nvar handler_fn \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(re_frame.subs.kind,query_id);\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___49998 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___49998);\n\n} else {\n}\n\nif(re_frame.interop.debug_enabled_QMARK_){\nvar temp__5804__auto___49999 \x3d cljs.core.not_empty(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(re_frame.interop.ratom_QMARK_,dynv));\nif(cljs.core.truth_(temp__5804__auto___49999)){\nvar not_reactive_50000 \x3d temp__5804__auto___49999;\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: your subscription\x27s dynamic parameters that don\x27t implement IReactiveAtom:\x22,not_reactive_50000], 0));\n} else {\n}\n} else {\n}\n\nif((handler_fn \x3d\x3d null)){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50001 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50001);\n\n} else {\n}\n\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([[\x22re-frame: no subscription handler registered for: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(query_id),\x22. Returning a nil subscription.\x22].join(\x27\x27)], 0));\n} else {\nvar dyn_vals \x3d re_frame.interop.make_reaction((function (){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.deref,dynv);\n}));\nvar sub \x3d re_frame.interop.make_reaction((function (){\nvar G__49885 \x3d re_frame.db.app_db;\nvar G__49886 \x3d query;\nvar G__49887 \x3d cljs.core.deref(dyn_vals);\nreturn (handler_fn.cljs$core$IFn$_invoke$arity$3 ? handler_fn.cljs$core$IFn$_invoke$arity$3(G__49885,G__49886,G__49887) : handler_fn.call(null,G__49885,G__49886,G__49887));\n}));\nreturn re_frame.subs.cache_and_return(query,dynv,re_frame.interop.make_reaction((function (){\nreturn cljs.core.deref(cljs.core.deref(sub));\n})));\n}\n}\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50005 \x3d re_frame.interop.now();\nvar duration__49765__auto___50006 \x3d (end__49764__auto___50005 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50006,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50005);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__49883);\n}} else {\nvar temp__5802__auto__ \x3d re_frame.subs.cache_lookup.cljs$core$IFn$_invoke$arity$2(query,dynv);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar cached \x3d temp__5802__auto__;\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50007 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),true,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),re_frame.interop.reagent_id(cached)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50007);\n\n} else {\n}\n\nreturn cached;\n} else {\nvar query_id \x3d re_frame.utils.first_in_vector(query);\nvar handler_fn \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(re_frame.subs.kind,query_id);\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50008 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22cached?\x22,\x22cached?\x22,86081880),false], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50008);\n\n} else {\n}\n\nif(re_frame.interop.debug_enabled_QMARK_){\nvar temp__5804__auto___50009 \x3d cljs.core.not_empty(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(re_frame.interop.ratom_QMARK_,dynv));\nif(cljs.core.truth_(temp__5804__auto___50009)){\nvar not_reactive_50010 \x3d temp__5804__auto___50009;\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: your subscription\x27s dynamic parameters that don\x27t implement IReactiveAtom:\x22,not_reactive_50010], 0));\n} else {\n}\n} else {\n}\n\nif((handler_fn \x3d\x3d null)){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50011 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),true], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50011);\n\n} else {\n}\n\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([[\x22re-frame: no subscription handler registered for: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(query_id),\x22. Returning a nil subscription.\x22].join(\x27\x27)], 0));\n} else {\nvar dyn_vals \x3d re_frame.interop.make_reaction((function (){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.deref,dynv);\n}));\nvar sub \x3d re_frame.interop.make_reaction((function (){\nvar G__49892 \x3d re_frame.db.app_db;\nvar G__49893 \x3d query;\nvar G__49894 \x3d cljs.core.deref(dyn_vals);\nreturn (handler_fn.cljs$core$IFn$_invoke$arity$3 ? handler_fn.cljs$core$IFn$_invoke$arity$3(G__49892,G__49893,G__49894) : handler_fn.call(null,G__49892,G__49893,G__49894));\n}));\nreturn re_frame.subs.cache_and_return(query,dynv,re_frame.interop.make_reaction((function (){\nreturn cljs.core.deref(cljs.core.deref(sub));\n})));\n}\n}\n}\n}));\n\n(re_frame.subs.subscribe.cljs$lang$maxFixedArity \x3d 2);\n\n/**\n * Returns a new version of \x27m\x27 in which \x27f\x27 has been applied to each value.\n *   (map-vals inc {:a 4, :b 2}) \x3d\x3e {:a 5, :b 3}\n */\nre_frame.subs.map_vals \x3d (function re_frame$subs$map_vals(f,m){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.empty(m),cljs.core.map.cljs$core$IFn$_invoke$arity$1((function (p__49895){\nvar vec__49896 \x3d p__49895;\nvar k \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49896,(0),null);\nvar v \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49896,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(v) : f.call(null,v))], null);\n})),m);\n});\n/**\n * Runs f over signals. Signals may take several\n *   forms, this function handles all of them.\n */\nre_frame.subs.map_signals \x3d (function re_frame$subs$map_signals(f,signals){\nif(cljs.core.sequential_QMARK_(signals)){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,signals);\n} else {\nif(cljs.core.map_QMARK_(signals)){\nreturn re_frame.subs.map_vals(f,signals);\n} else {\nif(re_frame.interop.deref_QMARK_(signals)){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(signals) : f.call(null,signals));\n} else {\nreturn cljs.core.List.EMPTY;\n\n}\n}\n}\n});\n/**\n * Coerces x to a seq if it isn\x27t one already\n */\nre_frame.subs.to_seq \x3d (function re_frame$subs$to_seq(x){\nif(cljs.core.sequential_QMARK_(x)){\nreturn x;\n} else {\nreturn (new cljs.core.List(null,x,null,(1),null));\n}\n});\nre_frame.subs.deref_input_signals \x3d (function re_frame$subs$deref_input_signals(signals,query_id){\nvar dereffed_signals \x3d re_frame.subs.map_signals(cljs.core.deref,signals);\nif(cljs.core.sequential_QMARK_(signals)){\ncljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.deref,signals);\n} else {\nif(cljs.core.map_QMARK_(signals)){\nre_frame.subs.map_vals(cljs.core.deref,signals);\n} else {\nif(re_frame.interop.deref_QMARK_(signals)){\ncljs.core.deref(signals);\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: in the reg-sub for\x22,query_id,\x22, the input-signals function returns:\x22,signals], 0));\n\n}\n}\n}\n\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50018 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22input-signals\x22,\x22input-signals\x22,563633497),cljs.core.doall.cljs$core$IFn$_invoke$arity$1(re_frame.subs.to_seq(re_frame.subs.map_signals(re_frame.interop.reagent_id,signals)))], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22input-signals\x22,\x22input-signals\x22,563633497),cljs.core.doall.cljs$core$IFn$_invoke$arity$1(re_frame.subs.to_seq(re_frame.subs.map_signals(re_frame.interop.reagent_id,signals)))], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50018);\n\n} else {\n}\n\nreturn dereffed_signals;\n});\nre_frame.subs.reg_sub \x3d (function re_frame$subs$reg_sub(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50021 \x3d arguments.length;\nvar i__5770__auto___50022 \x3d (0);\nwhile(true){\nif((i__5770__auto___50022 \x3c len__5769__auto___50021)){\nargs__5775__auto__.push((arguments[i__5770__auto___50022]));\n\nvar G__50023 \x3d (i__5770__auto___50022 + (1));\ni__5770__auto___50022 \x3d G__50023;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((1) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((1)),(0),null)):null);\nreturn re_frame.subs.reg_sub.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5776__auto__);\n});\n\n(re_frame.subs.reg_sub.cljs$core$IFn$_invoke$arity$variadic \x3d (function (query_id,args){\nvar err_header \x3d [\x22re-frame: reg-sub for \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(query_id),\x22, \x22].join(\x27\x27);\nvar vec__49903 \x3d (function (){var vec__49906 \x3d cljs.core.take_last((2),args);\nvar op \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49906,(0),null);\nvar f \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49906,(1),null);\nvar comp_f \x3d vec__49906;\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((1),cljs.core.count(comp_f))) || (((cljs.core.fn_QMARK_(op)) || (cljs.core.vector_QMARK_(op)))))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.butlast(args),cljs.core.last(args)], null);\n} else {\nvar args__$1 \x3d cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2((2),args);\nvar G__49909 \x3d op;\nvar G__49909__$1 \x3d (((G__49909 instanceof cljs.core.Keyword))?G__49909.fqn:null);\nswitch (G__49909__$1) {\ncase \x22-\x3e\x22:\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [args__$1,(function (db,_){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(db) : f.call(null,db));\n})], null);\n\nbreak;\ncase \x22\x3d\x3e\x22:\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [args__$1,(function (db,p__49910){\nvar vec__49911 \x3d p__49910;\nvar seq__49912 \x3d cljs.core.seq(vec__49911);\nvar first__49913 \x3d cljs.core.first(seq__49912);\nvar seq__49912__$1 \x3d cljs.core.next(seq__49912);\nvar _ \x3d first__49913;\nvar qs \x3d seq__49912__$1;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(f,db,qs);\n})], null);\n\nbreak;\ndefault:\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([err_header,\x22expected :-\x3e or :\x3d\x3e as second to last argument, got:\x22,op], 0));\n\n}\n}\n})();\nvar input_args \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49903,(0),null);\nvar computation_fn \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49903,(1),null);\nvar inputs_fn \x3d (function (){var G__49917 \x3d cljs.core.count(input_args);\nswitch (G__49917) {\ncase (0):\nreturn (function() {\nvar G__50033 \x3d null;\nvar G__50033__1 \x3d (function (_){\nreturn re_frame.db.app_db;\n});\nvar G__50033__2 \x3d (function (_,___$1){\nreturn re_frame.db.app_db;\n});\nG__50033 \x3d function(_,___$1){\nswitch(arguments.length){\ncase 1:\nreturn G__50033__1.call(this,_);\ncase 2:\nreturn G__50033__2.call(this,_,___$1);\n}\nthrow(new Error(\x27Invalid arity: \x27 + arguments.length));\n};\nG__50033.cljs$core$IFn$_invoke$arity$1 \x3d G__50033__1;\nG__50033.cljs$core$IFn$_invoke$arity$2 \x3d G__50033__2;\nreturn G__50033;\n})()\n\nbreak;\ncase (1):\nvar f \x3d cljs.core.first(input_args);\nif(cljs.core.fn_QMARK_(f)){\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([err_header,\x222nd argument expected to be an inputs function, got:\x22,f], 0));\n}\n\nreturn f;\n\nbreak;\ncase (2):\nvar vec__49920 \x3d input_args;\nvar marker \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49920,(0),null);\nvar vec \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49920,(1),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\x22\x3c-\x22,\x22\x3c-\x22,760412998),marker)){\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([err_header,\x22expected :\x3c-, got:\x22,marker], 0));\n}\n\nreturn (function() {\nvar re_frame$subs$inp_fn \x3d null;\nvar re_frame$subs$inp_fn__1 \x3d (function (_){\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$1(vec);\n});\nvar re_frame$subs$inp_fn__2 \x3d (function (_,___$1){\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$1(vec);\n});\nre_frame$subs$inp_fn \x3d function(_,___$1){\nswitch(arguments.length){\ncase 1:\nreturn re_frame$subs$inp_fn__1.call(this,_);\ncase 2:\nreturn re_frame$subs$inp_fn__2.call(this,_,___$1);\n}\nthrow(new Error(\x27Invalid arity: \x27 + arguments.length));\n};\nre_frame$subs$inp_fn.cljs$core$IFn$_invoke$arity$1 \x3d re_frame$subs$inp_fn__1;\nre_frame$subs$inp_fn.cljs$core$IFn$_invoke$arity$2 \x3d re_frame$subs$inp_fn__2;\nreturn re_frame$subs$inp_fn;\n})()\n\nbreak;\ndefault:\nvar pairs \x3d cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),input_args);\nvar markers \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,pairs);\nvar vecs \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.second,pairs);\nif(((cljs.core.every_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22\x3c-\x22,\x22\x3c-\x22,760412998),null], null), null),markers)) \x26\x26 (cljs.core.every_QMARK_(cljs.core.vector_QMARK_,vecs)))){\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([err_header,\x22expected pairs of :\x3c- and vectors, got:\x22,pairs], 0));\n}\n\nreturn (function() {\nvar re_frame$subs$inp_fn \x3d null;\nvar re_frame$subs$inp_fn__1 \x3d (function (_){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(re_frame.subs.subscribe,vecs);\n});\nvar re_frame$subs$inp_fn__2 \x3d (function (_,___$1){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(re_frame.subs.subscribe,vecs);\n});\nre_frame$subs$inp_fn \x3d function(_,___$1){\nswitch(arguments.length){\ncase 1:\nreturn re_frame$subs$inp_fn__1.call(this,_);\ncase 2:\nreturn re_frame$subs$inp_fn__2.call(this,_,___$1);\n}\nthrow(new Error(\x27Invalid arity: \x27 + arguments.length));\n};\nre_frame$subs$inp_fn.cljs$core$IFn$_invoke$arity$1 \x3d re_frame$subs$inp_fn__1;\nre_frame$subs$inp_fn.cljs$core$IFn$_invoke$arity$2 \x3d re_frame$subs$inp_fn__2;\nreturn re_frame$subs$inp_fn;\n})()\n\n}\n})();\nreturn re_frame.registrar.register_handler(re_frame.subs.kind,query_id,(function() {\nvar re_frame$subs$subs_handler_fn \x3d null;\nvar re_frame$subs$subs_handler_fn__2 \x3d (function (db,query_vec){\nvar subscriptions \x3d (inputs_fn.cljs$core$IFn$_invoke$arity$2 ? inputs_fn.cljs$core$IFn$_invoke$arity$2(query_vec,null) : inputs_fn.call(null,query_vec,null));\nvar reaction_id \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(null);\nvar reaction \x3d re_frame.interop.make_reaction((function (){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__49931 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__49932 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.utils.first_in_vector(query_vec),new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22sub\x22,\x22run\x22,\x22sub/run\x22,-1821315581),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22query-v\x22,\x22query-v\x22,-1514170131),query_vec,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),cljs.core.deref(reaction_id)], null)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__49932);\n\ntry{try{var subscription \x3d (function (){var G__49935 \x3d re_frame.subs.deref_input_signals(subscriptions,query_id);\nvar G__49936 \x3d query_vec;\nreturn (computation_fn.cljs$core$IFn$_invoke$arity$2 ? computation_fn.cljs$core$IFn$_invoke$arity$2(G__49935,G__49936) : computation_fn.call(null,G__49935,G__49936));\n})();\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50038 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50038);\n\n} else {\n}\n\nreturn subscription;\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50040 \x3d re_frame.interop.now();\nvar duration__49765__auto___50041 \x3d (end__49764__auto___50040 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50041,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50040);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__49931);\n}} else {\nvar subscription \x3d (function (){var G__49938 \x3d re_frame.subs.deref_input_signals(subscriptions,query_id);\nvar G__49939 \x3d query_vec;\nreturn (computation_fn.cljs$core$IFn$_invoke$arity$2 ? computation_fn.cljs$core$IFn$_invoke$arity$2(G__49938,G__49939) : computation_fn.call(null,G__49938,G__49939));\n})();\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50042 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50042);\n\n} else {\n}\n\nreturn subscription;\n}\n}));\ncljs.core.reset_BANG_(reaction_id,re_frame.interop.reagent_id(reaction));\n\nreturn reaction;\n});\nvar re_frame$subs$subs_handler_fn__3 \x3d (function (db,query_vec,dyn_vec){\nvar subscriptions \x3d (inputs_fn.cljs$core$IFn$_invoke$arity$2 ? inputs_fn.cljs$core$IFn$_invoke$arity$2(query_vec,dyn_vec) : inputs_fn.call(null,query_vec,dyn_vec));\nvar reaction_id \x3d cljs.core.atom.cljs$core$IFn$_invoke$arity$1(null);\nvar reaction \x3d re_frame.interop.make_reaction((function (){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__49940 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__49941 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.utils.first_in_vector(query_vec),new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22sub\x22,\x22run\x22,\x22sub/run\x22,-1821315581),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22query-v\x22,\x22query-v\x22,-1514170131),query_vec,new cljs.core.Keyword(null,\x22dyn-v\x22,\x22dyn-v\x22,949994592),dyn_vec,new cljs.core.Keyword(null,\x22reaction\x22,\x22reaction\x22,490869788),cljs.core.deref(reaction_id)], null)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__49941);\n\ntry{try{var subscription \x3d (function (){var G__49943 \x3d re_frame.subs.deref_input_signals(subscriptions,query_id);\nvar G__49944 \x3d query_vec;\nvar G__49945 \x3d dyn_vec;\nreturn (computation_fn.cljs$core$IFn$_invoke$arity$3 ? computation_fn.cljs$core$IFn$_invoke$arity$3(G__49943,G__49944,G__49945) : computation_fn.call(null,G__49943,G__49944,G__49945));\n})();\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50043 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50043);\n\n} else {\n}\n\nreturn subscription;\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50044 \x3d re_frame.interop.now();\nvar duration__49765__auto___50045 \x3d (end__49764__auto___50044 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50045,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50044);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__49940);\n}} else {\nvar subscription \x3d (function (){var G__49948 \x3d re_frame.subs.deref_input_signals(subscriptions,query_id);\nvar G__49949 \x3d query_vec;\nvar G__49950 \x3d dyn_vec;\nreturn (computation_fn.cljs$core$IFn$_invoke$arity$3 ? computation_fn.cljs$core$IFn$_invoke$arity$3(G__49948,G__49949,G__49950) : computation_fn.call(null,G__49948,G__49949,G__49950));\n})();\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50046 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22value\x22,\x22value\x22,305978217),subscription], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50046);\n\n} else {\n}\n\nreturn subscription;\n}\n}));\ncljs.core.reset_BANG_(reaction_id,re_frame.interop.reagent_id(reaction));\n\nreturn reaction;\n});\nre_frame$subs$subs_handler_fn \x3d function(db,query_vec,dyn_vec){\nswitch(arguments.length){\ncase 2:\nreturn re_frame$subs$subs_handler_fn__2.call(this,db,query_vec);\ncase 3:\nreturn re_frame$subs$subs_handler_fn__3.call(this,db,query_vec,dyn_vec);\n}\nthrow(new Error(\x27Invalid arity: \x27 + arguments.length));\n};\nre_frame$subs$subs_handler_fn.cljs$core$IFn$_invoke$arity$2 \x3d re_frame$subs$subs_handler_fn__2;\nre_frame$subs$subs_handler_fn.cljs$core$IFn$_invoke$arity$3 \x3d re_frame$subs$subs_handler_fn__3;\nreturn re_frame$subs$subs_handler_fn;\n})()\n);\n}));\n\n(re_frame.subs.reg_sub.cljs$lang$maxFixedArity \x3d (1));\n\n/** @this {Function} */\n(re_frame.subs.reg_sub.cljs$lang$applyTo \x3d (function (seq49901){\nvar G__49902 \x3d cljs.core.first(seq49901);\nvar seq49901__$1 \x3d cljs.core.next(seq49901);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__49902,seq49901__$1);\n}));\n\n");
SHADOW_ENV.evalLoad("re_frame.router.js", true , "goog.provide(\x27re_frame.router\x27);\nre_frame.router.later_fns \x3d new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22flush-dom\x22,\x22flush-dom\x22,-933676816),(function (f){\nvar G__50037 \x3d (function (){\nreturn (re_frame.interop.next_tick.cljs$core$IFn$_invoke$arity$1 ? re_frame.interop.next_tick.cljs$core$IFn$_invoke$arity$1(f) : re_frame.interop.next_tick.call(null,f));\n});\nreturn (re_frame.interop.after_render.cljs$core$IFn$_invoke$arity$1 ? re_frame.interop.after_render.cljs$core$IFn$_invoke$arity$1(G__50037) : re_frame.interop.after_render.call(null,G__50037));\n}),new cljs.core.Keyword(null,\x22yield\x22,\x22yield\x22,177875009),re_frame.interop.next_tick], null);\n\n/**\n * @interface\n */\nre_frame.router.IEventQueue \x3d function(){};\n\nvar re_frame$router$IEventQueue$push$dyn_50089 \x3d (function (this$,event){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router.push[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$2(this$,event) : m__5394__auto__.call(null,this$,event));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router.push[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$2(this$,event) : m__5392__auto__.call(null,this$,event));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.push\x22,this$);\n}\n}\n});\nre_frame.router.push \x3d (function re_frame$router$push(this$,event){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$push$arity$2 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$push$arity$2(this$,event);\n} else {\nreturn re_frame$router$IEventQueue$push$dyn_50089(this$,event);\n}\n});\n\nvar re_frame$router$IEventQueue$add_post_event_callback$dyn_50090 \x3d (function (this$,id,callback_fn){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router.add_post_event_callback[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$3 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$3(this$,id,callback_fn) : m__5394__auto__.call(null,this$,id,callback_fn));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router.add_post_event_callback[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$3 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$3(this$,id,callback_fn) : m__5392__auto__.call(null,this$,id,callback_fn));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.add-post-event-callback\x22,this$);\n}\n}\n});\nre_frame.router.add_post_event_callback \x3d (function re_frame$router$add_post_event_callback(this$,id,callback_fn){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$add_post_event_callback$arity$3 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$add_post_event_callback$arity$3(this$,id,callback_fn);\n} else {\nreturn re_frame$router$IEventQueue$add_post_event_callback$dyn_50090(this$,id,callback_fn);\n}\n});\n\nvar re_frame$router$IEventQueue$remove_post_event_callback$dyn_50091 \x3d (function (this$,id){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router.remove_post_event_callback[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$2(this$,id) : m__5394__auto__.call(null,this$,id));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router.remove_post_event_callback[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$2(this$,id) : m__5392__auto__.call(null,this$,id));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.remove-post-event-callback\x22,this$);\n}\n}\n});\nre_frame.router.remove_post_event_callback \x3d (function re_frame$router$remove_post_event_callback(this$,id){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$remove_post_event_callback$arity$2 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$remove_post_event_callback$arity$2(this$,id);\n} else {\nreturn re_frame$router$IEventQueue$remove_post_event_callback$dyn_50091(this$,id);\n}\n});\n\nvar re_frame$router$IEventQueue$purge$dyn_50096 \x3d (function (this$){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router.purge[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router.purge[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.purge\x22,this$);\n}\n}\n});\nre_frame.router.purge \x3d (function re_frame$router$purge(this$){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$purge$arity$1 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$purge$arity$1(this$);\n} else {\nreturn re_frame$router$IEventQueue$purge$dyn_50096(this$);\n}\n});\n\nvar re_frame$router$IEventQueue$_fsm_trigger$dyn_50097 \x3d (function (this$,trigger,arg){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._fsm_trigger[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$3 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$3(this$,trigger,arg) : m__5394__auto__.call(null,this$,trigger,arg));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._fsm_trigger[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$3 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$3(this$,trigger,arg) : m__5392__auto__.call(null,this$,trigger,arg));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-fsm-trigger\x22,this$);\n}\n}\n});\nre_frame.router._fsm_trigger \x3d (function re_frame$router$_fsm_trigger(this$,trigger,arg){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_fsm_trigger$arity$3 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_fsm_trigger$arity$3(this$,trigger,arg);\n} else {\nreturn re_frame$router$IEventQueue$_fsm_trigger$dyn_50097(this$,trigger,arg);\n}\n});\n\nvar re_frame$router$IEventQueue$_add_event$dyn_50099 \x3d (function (this$,event){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._add_event[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$2(this$,event) : m__5394__auto__.call(null,this$,event));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._add_event[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$2(this$,event) : m__5392__auto__.call(null,this$,event));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-add-event\x22,this$);\n}\n}\n});\nre_frame.router._add_event \x3d (function re_frame$router$_add_event(this$,event){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_add_event$arity$2 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_add_event$arity$2(this$,event);\n} else {\nreturn re_frame$router$IEventQueue$_add_event$dyn_50099(this$,event);\n}\n});\n\nvar re_frame$router$IEventQueue$_process_1st_event_in_queue$dyn_50100 \x3d (function (this$){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._process_1st_event_in_queue[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._process_1st_event_in_queue[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-process-1st-event-in-queue\x22,this$);\n}\n}\n});\nre_frame.router._process_1st_event_in_queue \x3d (function re_frame$router$_process_1st_event_in_queue(this$){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_process_1st_event_in_queue$arity$1 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_process_1st_event_in_queue$arity$1(this$);\n} else {\nreturn re_frame$router$IEventQueue$_process_1st_event_in_queue$dyn_50100(this$);\n}\n});\n\nvar re_frame$router$IEventQueue$_run_next_tick$dyn_50101 \x3d (function (this$){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._run_next_tick[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._run_next_tick[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-run-next-tick\x22,this$);\n}\n}\n});\nre_frame.router._run_next_tick \x3d (function re_frame$router$_run_next_tick(this$){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_run_next_tick$arity$1 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_run_next_tick$arity$1(this$);\n} else {\nreturn re_frame$router$IEventQueue$_run_next_tick$dyn_50101(this$);\n}\n});\n\nvar re_frame$router$IEventQueue$_run_queue$dyn_50103 \x3d (function (this$){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._run_queue[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._run_queue[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-run-queue\x22,this$);\n}\n}\n});\nre_frame.router._run_queue \x3d (function re_frame$router$_run_queue(this$){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_run_queue$arity$1 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_run_queue$arity$1(this$);\n} else {\nreturn re_frame$router$IEventQueue$_run_queue$dyn_50103(this$);\n}\n});\n\nvar re_frame$router$IEventQueue$_exception$dyn_50104 \x3d (function (this$,ex){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._exception[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$2(this$,ex) : m__5394__auto__.call(null,this$,ex));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._exception[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$2(this$,ex) : m__5392__auto__.call(null,this$,ex));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-exception\x22,this$);\n}\n}\n});\nre_frame.router._exception \x3d (function re_frame$router$_exception(this$,ex){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_exception$arity$2 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_exception$arity$2(this$,ex);\n} else {\nreturn re_frame$router$IEventQueue$_exception$dyn_50104(this$,ex);\n}\n});\n\nvar re_frame$router$IEventQueue$_pause$dyn_50109 \x3d (function (this$,later_fn){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._pause[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$2(this$,later_fn) : m__5394__auto__.call(null,this$,later_fn));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._pause[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$2(this$,later_fn) : m__5392__auto__.call(null,this$,later_fn));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-pause\x22,this$);\n}\n}\n});\nre_frame.router._pause \x3d (function re_frame$router$_pause(this$,later_fn){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_pause$arity$2 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_pause$arity$2(this$,later_fn);\n} else {\nreturn re_frame$router$IEventQueue$_pause$dyn_50109(this$,later_fn);\n}\n});\n\nvar re_frame$router$IEventQueue$_resume$dyn_50110 \x3d (function (this$){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._resume[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5394__auto__.call(null,this$));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._resume[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$1 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__5392__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-resume\x22,this$);\n}\n}\n});\nre_frame.router._resume \x3d (function re_frame$router$_resume(this$){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_resume$arity$1 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_resume$arity$1(this$);\n} else {\nreturn re_frame$router$IEventQueue$_resume$dyn_50110(this$);\n}\n});\n\nvar re_frame$router$IEventQueue$_call_post_event_callbacks$dyn_50111 \x3d (function (this$,event){\nvar x__5393__auto__ \x3d (((this$ \x3d\x3d null))?null:this$);\nvar m__5394__auto__ \x3d (re_frame.router._call_post_event_callbacks[goog.typeOf(x__5393__auto__)]);\nif((!((m__5394__auto__ \x3d\x3d null)))){\nreturn (m__5394__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5394__auto__.cljs$core$IFn$_invoke$arity$2(this$,event) : m__5394__auto__.call(null,this$,event));\n} else {\nvar m__5392__auto__ \x3d (re_frame.router._call_post_event_callbacks[\x22_\x22]);\nif((!((m__5392__auto__ \x3d\x3d null)))){\nreturn (m__5392__auto__.cljs$core$IFn$_invoke$arity$2 ? m__5392__auto__.cljs$core$IFn$_invoke$arity$2(this$,event) : m__5392__auto__.call(null,this$,event));\n} else {\nthrow cljs.core.missing_protocol(\x22IEventQueue.-call-post-event-callbacks\x22,this$);\n}\n}\n});\nre_frame.router._call_post_event_callbacks \x3d (function re_frame$router$_call_post_event_callbacks(this$,event){\nif((((!((this$ \x3d\x3d null)))) \x26\x26 ((!((this$.re_frame$router$IEventQueue$_call_post_event_callbacks$arity$2 \x3d\x3d null)))))){\nreturn this$.re_frame$router$IEventQueue$_call_post_event_callbacks$arity$2(this$,event);\n} else {\nreturn re_frame$router$IEventQueue$_call_post_event_callbacks$dyn_50111(this$,event);\n}\n});\n\n\n/**\n* @constructor\n * @implements {re_frame.router.IEventQueue}\n*/\nre_frame.router.EventQueue \x3d (function (fsm_state,queue,post_event_callback_fns){\nthis.fsm_state \x3d fsm_state;\nthis.queue \x3d queue;\nthis.post_event_callback_fns \x3d post_event_callback_fns;\n});\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$ \x3d cljs.core.PROTOCOL_SENTINEL);\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_run_queue$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar n \x3d cljs.core.count(self__.queue);\nwhile(true){\nif((n \x3d\x3d\x3d (0))){\nreturn this$__$1.re_frame$router$IEventQueue$_fsm_trigger$arity$3(null,new cljs.core.Keyword(null,\x22finish-run\x22,\x22finish-run\x22,753148477),null);\n} else {\nvar temp__5802__auto__ \x3d cljs.core.some(re_frame.router.later_fns,cljs.core.keys(cljs.core.meta(cljs.core.peek(self__.queue))));\nif(cljs.core.truth_(temp__5802__auto__)){\nvar later_fn \x3d temp__5802__auto__;\nreturn this$__$1.re_frame$router$IEventQueue$_fsm_trigger$arity$3(null,new cljs.core.Keyword(null,\x22pause\x22,\x22pause\x22,-2095325672),later_fn);\n} else {\nthis$__$1.re_frame$router$IEventQueue$_process_1st_event_in_queue$arity$1(null);\n\nvar G__50112 \x3d (n - (1));\nn \x3d G__50112;\ncontinue;\n}\n}\nbreak;\n}\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$remove_post_event_callback$arity$2 \x3d (function (_,id){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif((!(cljs.core.contains_QMARK_(self__.post_event_callback_fns,id)))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: could not remove post event call back with id:\x22,id], 0));\n} else {\nreturn (self__.post_event_callback_fns \x3d cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.post_event_callback_fns,id));\n}\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_add_event$arity$2 \x3d (function (_,event){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (self__.queue \x3d cljs.core.conj.cljs$core$IFn$_invoke$arity$2(self__.queue,event));\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_resume$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nthis$__$1.re_frame$router$IEventQueue$_process_1st_event_in_queue$arity$1(null);\n\nreturn this$__$1.re_frame$router$IEventQueue$_run_queue$arity$1(null);\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$push$arity$2 \x3d (function (this$,event){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nreturn this$__$1.re_frame$router$IEventQueue$_fsm_trigger$arity$3(null,new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088),event);\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_run_next_tick$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar G__50072 \x3d (function (){\nreturn this$__$1.re_frame$router$IEventQueue$_fsm_trigger$arity$3(null,new cljs.core.Keyword(null,\x22run-queue\x22,\x22run-queue\x22,-1701798027),null);\n});\nreturn (re_frame.interop.next_tick.cljs$core$IFn$_invoke$arity$1 ? re_frame.interop.next_tick.cljs$core$IFn$_invoke$arity$1(G__50072) : re_frame.interop.next_tick.call(null,G__50072));\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_fsm_trigger$arity$3 \x3d (function (this$,trigger,arg){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__50073 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__50074 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22re-frame.router\x22,\x22fsm-trigger\x22,\x22re-frame.router/fsm-trigger\x22,1379787274)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__50074);\n\ntry{try{var vec__50075 \x3d (function (){var G__50078 \x3d new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.fsm_state,trigger], null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),(function (){\nthis$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n\nreturn this$__$1.re_frame$router$IEventQueue$_run_next_tick$arity$1(null);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22exception\x22,\x22exception\x22,-335277064)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_exception$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22finish-run\x22,\x22finish-run\x22,753148477)], null),G__50078)){\nif(cljs.core.empty_QMARK_(self__.queue)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_run_next_tick$arity$1(null);\n})], null);\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22pause\x22,\x22pause\x22,-2095325672)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_pause$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),new cljs.core.Keyword(null,\x22resume\x22,\x22resume\x22,-118572261)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_resume$arity$1(null);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),new cljs.core.Keyword(null,\x22run-queue\x22,\x22run-queue\x22,-1701798027)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_run_queue$arity$1(null);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50078)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n})], null);\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2([\x22re-frame: router state transition not found. \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.fsm_state),\x22 \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(trigger)].join(\x27\x27),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22fsm-state\x22,\x22fsm-state\x22,1656310533),self__.fsm_state,new cljs.core.Keyword(null,\x22trigger\x22,\x22trigger\x22,103466139),trigger], null));\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n})();\nvar new_fsm_state \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50075,(0),null);\nvar action_fn \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50075,(1),null);\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50113 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.fsm_state,trigger], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22current-state\x22,\x22current-state\x22,1048284452),self__.fsm_state,new cljs.core.Keyword(null,\x22new-state\x22,\x22new-state\x22,-490349212),new_fsm_state], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.fsm_state,trigger], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22current-state\x22,\x22current-state\x22,1048284452),self__.fsm_state,new cljs.core.Keyword(null,\x22new-state\x22,\x22new-state\x22,-490349212),new_fsm_state], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50113);\n\n} else {\n}\n\n(self__.fsm_state \x3d new_fsm_state);\n\nif(cljs.core.truth_(action_fn)){\nreturn (action_fn.cljs$core$IFn$_invoke$arity$0 ? action_fn.cljs$core$IFn$_invoke$arity$0() : action_fn.call(null));\n} else {\nreturn null;\n}\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50114 \x3d re_frame.interop.now();\nvar duration__49765__auto___50115 \x3d (end__49764__auto___50114 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50115,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50114);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__50073);\n}} else {\nvar vec__50079 \x3d (function (){var G__50082 \x3d new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.fsm_state,trigger], null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),(function (){\nthis$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n\nreturn this$__$1.re_frame$router$IEventQueue$_run_next_tick$arity$1(null);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22exception\x22,\x22exception\x22,-335277064)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_exception$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22finish-run\x22,\x22finish-run\x22,753148477)], null),G__50082)){\nif(cljs.core.empty_QMARK_(self__.queue)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_run_next_tick$arity$1(null);\n})], null);\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22pause\x22,\x22pause\x22,-2095325672)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_pause$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),new cljs.core.Keyword(null,\x22resume\x22,\x22resume\x22,-118572261)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_resume$arity$1(null);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),new cljs.core.Keyword(null,\x22run-queue\x22,\x22run-queue\x22,-1701798027)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_run_queue$arity$1(null);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22paused\x22,\x22paused\x22,-1710376127),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22running\x22,\x22running\x22,1554969103),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n})], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),new cljs.core.Keyword(null,\x22add-event\x22,\x22add-event\x22,938429088)], null),G__50082)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\x22scheduled\x22,\x22scheduled\x22,553898551),(function (){\nreturn this$__$1.re_frame$router$IEventQueue$_add_event$arity$2(null,arg);\n})], null);\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2([\x22re-frame: router state transition not found. \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.fsm_state),\x22 \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(trigger)].join(\x27\x27),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22fsm-state\x22,\x22fsm-state\x22,1656310533),self__.fsm_state,new cljs.core.Keyword(null,\x22trigger\x22,\x22trigger\x22,103466139),trigger], null));\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n})();\nvar new_fsm_state \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50079,(0),null);\nvar action_fn \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50079,(1),null);\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50118 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.fsm_state,trigger], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22current-state\x22,\x22current-state\x22,1048284452),self__.fsm_state,new cljs.core.Keyword(null,\x22new-state\x22,\x22new-state\x22,-490349212),new_fsm_state], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.fsm_state,trigger], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22current-state\x22,\x22current-state\x22,1048284452),self__.fsm_state,new cljs.core.Keyword(null,\x22new-state\x22,\x22new-state\x22,-490349212),new_fsm_state], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50118);\n\n} else {\n}\n\n(self__.fsm_state \x3d new_fsm_state);\n\nif(cljs.core.truth_(action_fn)){\nreturn (action_fn.cljs$core$IFn$_invoke$arity$0 ? action_fn.cljs$core$IFn$_invoke$arity$0() : action_fn.call(null));\n} else {\nreturn null;\n}\n}\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_pause$arity$2 \x3d (function (this$,later_fn){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar G__50083 \x3d (function (){\nreturn this$__$1.re_frame$router$IEventQueue$_fsm_trigger$arity$3(null,new cljs.core.Keyword(null,\x22resume\x22,\x22resume\x22,-118572261),null);\n});\nreturn (later_fn.cljs$core$IFn$_invoke$arity$1 ? later_fn.cljs$core$IFn$_invoke$arity$1(G__50083) : later_fn.call(null,G__50083));\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$add_post_event_callback$arity$3 \x3d (function (_,id,callback_fn){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nif(cljs.core.contains_QMARK_(self__.post_event_callback_fns,id)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: overwriting existing post event call back with id:\x22,id], 0));\n} else {\n}\n\nreturn (self__.post_event_callback_fns \x3d cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.post_event_callback_fns,id,callback_fn));\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_process_1st_event_in_queue$arity$1 \x3d (function (this$){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nvar event_v \x3d cljs.core.peek(self__.queue);\ntry{re_frame.events.handle(event_v);\n\n(self__.queue \x3d cljs.core.pop(self__.queue));\n\nreturn this$__$1.re_frame$router$IEventQueue$_call_post_event_callbacks$arity$2(null,event_v);\n}catch (e50084){var ex \x3d e50084;\nreturn this$__$1.re_frame$router$IEventQueue$_fsm_trigger$arity$3(null,new cljs.core.Keyword(null,\x22exception\x22,\x22exception\x22,-335277064),ex);\n}}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_call_post_event_callbacks$arity$2 \x3d (function (_,event_v){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nvar seq__50085 \x3d cljs.core.seq(cljs.core.vals(self__.post_event_callback_fns));\nvar chunk__50086 \x3d null;\nvar count__50087 \x3d (0);\nvar i__50088 \x3d (0);\nwhile(true){\nif((i__50088 \x3c count__50087)){\nvar callback \x3d chunk__50086.cljs$core$IIndexed$_nth$arity$2(null,i__50088);\n(callback.cljs$core$IFn$_invoke$arity$2 ? callback.cljs$core$IFn$_invoke$arity$2(event_v,self__.queue) : callback.call(null,event_v,self__.queue));\n\n\nvar G__50128 \x3d seq__50085;\nvar G__50129 \x3d chunk__50086;\nvar G__50130 \x3d count__50087;\nvar G__50131 \x3d (i__50088 + (1));\nseq__50085 \x3d G__50128;\nchunk__50086 \x3d G__50129;\ncount__50087 \x3d G__50130;\ni__50088 \x3d G__50131;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50085);\nif(temp__5804__auto__){\nvar seq__50085__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50085__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50085__$1);\nvar G__50135 \x3d cljs.core.chunk_rest(seq__50085__$1);\nvar G__50136 \x3d c__5568__auto__;\nvar G__50137 \x3d cljs.core.count(c__5568__auto__);\nvar G__50138 \x3d (0);\nseq__50085 \x3d G__50135;\nchunk__50086 \x3d G__50136;\ncount__50087 \x3d G__50137;\ni__50088 \x3d G__50138;\ncontinue;\n} else {\nvar callback \x3d cljs.core.first(seq__50085__$1);\n(callback.cljs$core$IFn$_invoke$arity$2 ? callback.cljs$core$IFn$_invoke$arity$2(event_v,self__.queue) : callback.call(null,event_v,self__.queue));\n\n\nvar G__50139 \x3d cljs.core.next(seq__50085__$1);\nvar G__50140 \x3d null;\nvar G__50141 \x3d (0);\nvar G__50142 \x3d (0);\nseq__50085 \x3d G__50139;\nchunk__50086 \x3d G__50140;\ncount__50087 \x3d G__50141;\ni__50088 \x3d G__50142;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$purge$arity$1 \x3d (function (_){\nvar self__ \x3d this;\nvar ___$1 \x3d this;\nreturn (self__.queue \x3d re_frame.interop.empty_queue);\n}));\n\n(re_frame.router.EventQueue.prototype.re_frame$router$IEventQueue$_exception$arity$2 \x3d (function (this$,ex){\nvar self__ \x3d this;\nvar this$__$1 \x3d this;\nthis$__$1.re_frame$router$IEventQueue$purge$arity$1(null);\n\nthrow ex;\n}));\n\n(re_frame.router.EventQueue.getBasis \x3d (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\x22fsm-state\x22,\x22fsm-state\x22,-998125236,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22mutable\x22,\x22mutable\x22,875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22queue\x22,\x22queue\x22,-1198599890,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22mutable\x22,\x22mutable\x22,875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22post-event-callback-fns\x22,\x22post-event-callback-fns\x22,-297038335,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22mutable\x22,\x22mutable\x22,875778266),true], null))], null);\n}));\n\n(re_frame.router.EventQueue.cljs$lang$type \x3d true);\n\n(re_frame.router.EventQueue.cljs$lang$ctorStr \x3d \x22re-frame.router/EventQueue\x22);\n\n(re_frame.router.EventQueue.cljs$lang$ctorPrWriter \x3d (function (this__5330__auto__,writer__5331__auto__,opt__5332__auto__){\nreturn cljs.core._write(writer__5331__auto__,\x22re-frame.router/EventQueue\x22);\n}));\n\n/**\n * Positional factory function for re-frame.router/EventQueue.\n */\nre_frame.router.__GT_EventQueue \x3d (function re_frame$router$__GT_EventQueue(fsm_state,queue,post_event_callback_fns){\nreturn (new re_frame.router.EventQueue(fsm_state,queue,post_event_callback_fns));\n});\n\nre_frame.router.event_queue \x3d re_frame.router.__GT_EventQueue(new cljs.core.Keyword(null,\x22idle\x22,\x22idle\x22,-2007156861),re_frame.interop.empty_queue,cljs.core.PersistentArrayMap.EMPTY);\nre_frame.router.dispatch \x3d (function re_frame$router$dispatch(event){\nif((event \x3d\x3d null)){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\x22re-frame: you called \\\x22dispatch\\\x22 without an event vector.\x22,cljs.core.PersistentArrayMap.EMPTY);\n} else {\nre_frame.router.event_queue.re_frame$router$IEventQueue$push$arity$2(null,event);\n}\n\nreturn null;\n});\nre_frame.router.dispatch_sync \x3d (function re_frame$router$dispatch_sync(event_v){\nre_frame.events.handle(event_v);\n\nre_frame.router.event_queue.re_frame$router$IEventQueue$_call_post_event_callbacks$arity$2(null,event_v);\n\nreturn null;\n});\n");
SHADOW_ENV.evalLoad("re_frame.fx.js", true , "goog.provide(\x27re_frame.fx\x27);\nre_frame.fx.kind \x3d new cljs.core.Keyword(null,\x22fx\x22,\x22fx\x22,-1237829572);\nif(cljs.core.truth_((re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1 ? re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1(re_frame.fx.kind) : re_frame.registrar.kinds.call(null,re_frame.fx.kind)))){\n} else {\nthrow (new Error(\x22Assert failed: (re-frame.registrar/kinds kind)\x22));\n}\nre_frame.fx.reg_fx \x3d (function re_frame$fx$reg_fx(id,handler){\nreturn re_frame.registrar.register_handler(re_frame.fx.kind,id,handler);\n});\n/**\n * An interceptor whose `:after` actions the contents of `:effects`. As a result,\n *   this interceptor is Domino 3.\n * \n *   This interceptor is silently added (by reg-event-db etc) to the front of\n *   interceptor chains for all events.\n * \n *   For each key in `:effects` (a map), it calls the registered `effects handler`\n *   (see `reg-fx` for registration of effect handlers).\n * \n *   So, if `:effects` was:\n *    {:dispatch  [:hello 42]\n *     :db        {...}\n *     :undo      \x22set flag\x22}\n * \n *   it will call the registered effect handlers for each of the map\x27s keys:\n *   `:dispatch`, `:undo` and `:db`. When calling each handler, provides the map\n *   value for that key - so in the example above the effect handler for :dispatch\n *   will be given one arg `[:hello 42]`.\n * \n *   You cannot rely on the ordering in which effects are executed, other than that\n *   `:db` is guaranteed to be executed first.\n */\nre_frame.fx.do_fx \x3d re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22do-fx\x22,\x22do-fx\x22,1194163050),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$fx$do_fx_after(context){\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar _STAR_current_trace_STAR__orig_val__50116 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__50117 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22event\x22,\x22do-fx\x22,\x22event/do-fx\x22,1357330452)], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__50117);\n\ntry{try{var effects \x3d new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292).cljs$core$IFn$_invoke$arity$1(context);\nvar effects_without_db \x3d cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(effects,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar temp__5804__auto___50221 \x3d new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759).cljs$core$IFn$_invoke$arity$1(effects);\nif(cljs.core.truth_(temp__5804__auto___50221)){\nvar new_db_50222 \x3d temp__5804__auto___50221;\nvar fexpr__50119_50223 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),false);\n(fexpr__50119_50223.cljs$core$IFn$_invoke$arity$1 ? fexpr__50119_50223.cljs$core$IFn$_invoke$arity$1(new_db_50222) : fexpr__50119_50223.call(null,new_db_50222));\n} else {\n}\n\nvar seq__50120 \x3d cljs.core.seq(effects_without_db);\nvar chunk__50121 \x3d null;\nvar count__50122 \x3d (0);\nvar i__50123 \x3d (0);\nwhile(true){\nif((i__50123 \x3c count__50122)){\nvar vec__50146 \x3d chunk__50121.cljs$core$IIndexed$_nth$arity$2(null,i__50123);\nvar effect_key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50146,(0),null);\nvar effect_value \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50146,(1),null);\nvar temp__5802__auto___50224 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,effect_key,false);\nif(cljs.core.truth_(temp__5802__auto___50224)){\nvar effect_fn_50225 \x3d temp__5802__auto___50224;\n(effect_fn_50225.cljs$core$IFn$_invoke$arity$1 ? effect_fn_50225.cljs$core$IFn$_invoke$arity$1(effect_value) : effect_fn_50225.call(null,effect_value));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: no handler registered for effect:\x22,effect_key,\x22. Ignoring.\x22], 0));\n}\n\n\nvar G__50226 \x3d seq__50120;\nvar G__50227 \x3d chunk__50121;\nvar G__50228 \x3d count__50122;\nvar G__50229 \x3d (i__50123 + (1));\nseq__50120 \x3d G__50226;\nchunk__50121 \x3d G__50227;\ncount__50122 \x3d G__50228;\ni__50123 \x3d G__50229;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50120);\nif(temp__5804__auto__){\nvar seq__50120__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50120__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50120__$1);\nvar G__50230 \x3d cljs.core.chunk_rest(seq__50120__$1);\nvar G__50231 \x3d c__5568__auto__;\nvar G__50232 \x3d cljs.core.count(c__5568__auto__);\nvar G__50233 \x3d (0);\nseq__50120 \x3d G__50230;\nchunk__50121 \x3d G__50231;\ncount__50122 \x3d G__50232;\ni__50123 \x3d G__50233;\ncontinue;\n} else {\nvar vec__50149 \x3d cljs.core.first(seq__50120__$1);\nvar effect_key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50149,(0),null);\nvar effect_value \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50149,(1),null);\nvar temp__5802__auto___50234 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,effect_key,false);\nif(cljs.core.truth_(temp__5802__auto___50234)){\nvar effect_fn_50236 \x3d temp__5802__auto___50234;\n(effect_fn_50236.cljs$core$IFn$_invoke$arity$1 ? effect_fn_50236.cljs$core$IFn$_invoke$arity$1(effect_value) : effect_fn_50236.call(null,effect_value));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: no handler registered for effect:\x22,effect_key,\x22. Ignoring.\x22], 0));\n}\n\n\nvar G__50237 \x3d cljs.core.next(seq__50120__$1);\nvar G__50238 \x3d null;\nvar G__50239 \x3d (0);\nvar G__50240 \x3d (0);\nseq__50120 \x3d G__50237;\nchunk__50121 \x3d G__50238;\ncount__50122 \x3d G__50239;\ni__50123 \x3d G__50240;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50242 \x3d re_frame.interop.now();\nvar duration__49765__auto___50243 \x3d (end__49764__auto___50242 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50243,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50242);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__50116);\n}} else {\nvar effects \x3d new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292).cljs$core$IFn$_invoke$arity$1(context);\nvar effects_without_db \x3d cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(effects,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar temp__5804__auto___50244 \x3d new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759).cljs$core$IFn$_invoke$arity$1(effects);\nif(cljs.core.truth_(temp__5804__auto___50244)){\nvar new_db_50245 \x3d temp__5804__auto___50244;\nvar fexpr__50152_50246 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),false);\n(fexpr__50152_50246.cljs$core$IFn$_invoke$arity$1 ? fexpr__50152_50246.cljs$core$IFn$_invoke$arity$1(new_db_50245) : fexpr__50152_50246.call(null,new_db_50245));\n} else {\n}\n\nvar seq__50153 \x3d cljs.core.seq(effects_without_db);\nvar chunk__50154 \x3d null;\nvar count__50155 \x3d (0);\nvar i__50156 \x3d (0);\nwhile(true){\nif((i__50156 \x3c count__50155)){\nvar vec__50164 \x3d chunk__50154.cljs$core$IIndexed$_nth$arity$2(null,i__50156);\nvar effect_key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50164,(0),null);\nvar effect_value \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50164,(1),null);\nvar temp__5802__auto___50247 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,effect_key,false);\nif(cljs.core.truth_(temp__5802__auto___50247)){\nvar effect_fn_50248 \x3d temp__5802__auto___50247;\n(effect_fn_50248.cljs$core$IFn$_invoke$arity$1 ? effect_fn_50248.cljs$core$IFn$_invoke$arity$1(effect_value) : effect_fn_50248.call(null,effect_value));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: no handler registered for effect:\x22,effect_key,\x22. Ignoring.\x22], 0));\n}\n\n\nvar G__50249 \x3d seq__50153;\nvar G__50250 \x3d chunk__50154;\nvar G__50251 \x3d count__50155;\nvar G__50252 \x3d (i__50156 + (1));\nseq__50153 \x3d G__50249;\nchunk__50154 \x3d G__50250;\ncount__50155 \x3d G__50251;\ni__50156 \x3d G__50252;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50153);\nif(temp__5804__auto__){\nvar seq__50153__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50153__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50153__$1);\nvar G__50255 \x3d cljs.core.chunk_rest(seq__50153__$1);\nvar G__50256 \x3d c__5568__auto__;\nvar G__50257 \x3d cljs.core.count(c__5568__auto__);\nvar G__50258 \x3d (0);\nseq__50153 \x3d G__50255;\nchunk__50154 \x3d G__50256;\ncount__50155 \x3d G__50257;\ni__50156 \x3d G__50258;\ncontinue;\n} else {\nvar vec__50168 \x3d cljs.core.first(seq__50153__$1);\nvar effect_key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50168,(0),null);\nvar effect_value \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50168,(1),null);\nvar temp__5802__auto___50259 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,effect_key,false);\nif(cljs.core.truth_(temp__5802__auto___50259)){\nvar effect_fn_50260 \x3d temp__5802__auto___50259;\n(effect_fn_50260.cljs$core$IFn$_invoke$arity$1 ? effect_fn_50260.cljs$core$IFn$_invoke$arity$1(effect_value) : effect_fn_50260.call(null,effect_value));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: no handler registered for effect:\x22,effect_key,\x22. Ignoring.\x22], 0));\n}\n\n\nvar G__50261 \x3d cljs.core.next(seq__50153__$1);\nvar G__50262 \x3d null;\nvar G__50263 \x3d (0);\nvar G__50264 \x3d (0);\nseq__50153 \x3d G__50261;\nchunk__50154 \x3d G__50262;\ncount__50155 \x3d G__50263;\ni__50156 \x3d G__50264;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}\n})], 0));\nre_frame.fx.dispatch_later \x3d (function re_frame$fx$dispatch_later(p__50173){\nvar map__50175 \x3d p__50173;\nvar map__50175__$1 \x3d cljs.core.__destructure_map(map__50175);\nvar effect \x3d map__50175__$1;\nvar ms \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50175__$1,new cljs.core.Keyword(null,\x22ms\x22,\x22ms\x22,-1152709733));\nvar dispatch \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50175__$1,new cljs.core.Keyword(null,\x22dispatch\x22,\x22dispatch\x22,1319337009));\nif(((cljs.core.empty_QMARK_(dispatch)) || ((!(typeof ms \x3d\x3d\x3d \x27number\x27))))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: ignoring bad :dispatch-later value:\x22,effect], 0));\n} else {\nreturn re_frame.interop.set_timeout_BANG_((function (){\nreturn re_frame.router.dispatch(dispatch);\n}),ms);\n}\n});\nre_frame.fx.reg_fx(new cljs.core.Keyword(null,\x22dispatch-later\x22,\x22dispatch-later\x22,291951390),(function (value){\nif(cljs.core.map_QMARK_(value)){\nreturn re_frame.fx.dispatch_later(value);\n} else {\nvar seq__50183 \x3d cljs.core.seq(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,value));\nvar chunk__50184 \x3d null;\nvar count__50185 \x3d (0);\nvar i__50186 \x3d (0);\nwhile(true){\nif((i__50186 \x3c count__50185)){\nvar effect \x3d chunk__50184.cljs$core$IIndexed$_nth$arity$2(null,i__50186);\nre_frame.fx.dispatch_later(effect);\n\n\nvar G__50266 \x3d seq__50183;\nvar G__50267 \x3d chunk__50184;\nvar G__50268 \x3d count__50185;\nvar G__50269 \x3d (i__50186 + (1));\nseq__50183 \x3d G__50266;\nchunk__50184 \x3d G__50267;\ncount__50185 \x3d G__50268;\ni__50186 \x3d G__50269;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50183);\nif(temp__5804__auto__){\nvar seq__50183__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50183__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50183__$1);\nvar G__50271 \x3d cljs.core.chunk_rest(seq__50183__$1);\nvar G__50272 \x3d c__5568__auto__;\nvar G__50273 \x3d cljs.core.count(c__5568__auto__);\nvar G__50274 \x3d (0);\nseq__50183 \x3d G__50271;\nchunk__50184 \x3d G__50272;\ncount__50185 \x3d G__50273;\ni__50186 \x3d G__50274;\ncontinue;\n} else {\nvar effect \x3d cljs.core.first(seq__50183__$1);\nre_frame.fx.dispatch_later(effect);\n\n\nvar G__50275 \x3d cljs.core.next(seq__50183__$1);\nvar G__50276 \x3d null;\nvar G__50277 \x3d (0);\nvar G__50278 \x3d (0);\nseq__50183 \x3d G__50275;\nchunk__50184 \x3d G__50276;\ncount__50185 \x3d G__50277;\ni__50186 \x3d G__50278;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}\n}));\nre_frame.fx.reg_fx(new cljs.core.Keyword(null,\x22fx\x22,\x22fx\x22,-1237829572),(function (seq_of_effects){\nif((!(cljs.core.sequential_QMARK_(seq_of_effects)))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22:fx\\\x22 effect expects a seq, but was given \x22,cljs.core.type(seq_of_effects)], 0));\n} else {\nvar seq__50188 \x3d cljs.core.seq(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,seq_of_effects));\nvar chunk__50189 \x3d null;\nvar count__50190 \x3d (0);\nvar i__50191 \x3d (0);\nwhile(true){\nif((i__50191 \x3c count__50190)){\nvar vec__50198 \x3d chunk__50189.cljs$core$IIndexed$_nth$arity$2(null,i__50191);\nvar effect_key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50198,(0),null);\nvar effect_value \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50198,(1),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),effect_key)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22:fx\\\x22 effect should not contain a :db effect\x22], 0));\n} else {\n}\n\nvar temp__5802__auto___50279 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,effect_key,false);\nif(cljs.core.truth_(temp__5802__auto___50279)){\nvar effect_fn_50280 \x3d temp__5802__auto___50279;\n(effect_fn_50280.cljs$core$IFn$_invoke$arity$1 ? effect_fn_50280.cljs$core$IFn$_invoke$arity$1(effect_value) : effect_fn_50280.call(null,effect_value));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: in \\\x22:fx\\\x22 effect found \x22,effect_key,\x22 which has no associated handler. Ignoring.\x22], 0));\n}\n\n\nvar G__50281 \x3d seq__50188;\nvar G__50282 \x3d chunk__50189;\nvar G__50283 \x3d count__50190;\nvar G__50284 \x3d (i__50191 + (1));\nseq__50188 \x3d G__50281;\nchunk__50189 \x3d G__50282;\ncount__50190 \x3d G__50283;\ni__50191 \x3d G__50284;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50188);\nif(temp__5804__auto__){\nvar seq__50188__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50188__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50188__$1);\nvar G__50285 \x3d cljs.core.chunk_rest(seq__50188__$1);\nvar G__50286 \x3d c__5568__auto__;\nvar G__50287 \x3d cljs.core.count(c__5568__auto__);\nvar G__50288 \x3d (0);\nseq__50188 \x3d G__50285;\nchunk__50189 \x3d G__50286;\ncount__50190 \x3d G__50287;\ni__50191 \x3d G__50288;\ncontinue;\n} else {\nvar vec__50201 \x3d cljs.core.first(seq__50188__$1);\nvar effect_key \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50201,(0),null);\nvar effect_value \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50201,(1),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),effect_key)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22:fx\\\x22 effect should not contain a :db effect\x22], 0));\n} else {\n}\n\nvar temp__5802__auto___50289 \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3(re_frame.fx.kind,effect_key,false);\nif(cljs.core.truth_(temp__5802__auto___50289)){\nvar effect_fn_50290 \x3d temp__5802__auto___50289;\n(effect_fn_50290.cljs$core$IFn$_invoke$arity$1 ? effect_fn_50290.cljs$core$IFn$_invoke$arity$1(effect_value) : effect_fn_50290.call(null,effect_value));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: in \\\x22:fx\\\x22 effect found \x22,effect_key,\x22 which has no associated handler. Ignoring.\x22], 0));\n}\n\n\nvar G__50293 \x3d cljs.core.next(seq__50188__$1);\nvar G__50294 \x3d null;\nvar G__50295 \x3d (0);\nvar G__50296 \x3d (0);\nseq__50188 \x3d G__50293;\nchunk__50189 \x3d G__50294;\ncount__50190 \x3d G__50295;\ni__50191 \x3d G__50296;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}\n}));\nre_frame.fx.reg_fx(new cljs.core.Keyword(null,\x22dispatch\x22,\x22dispatch\x22,1319337009),(function (value){\nif((!(cljs.core.vector_QMARK_(value)))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: ignoring bad :dispatch value. Expected a vector, but got:\x22,value], 0));\n} else {\nreturn re_frame.router.dispatch(value);\n}\n}));\nre_frame.fx.reg_fx(new cljs.core.Keyword(null,\x22dispatch-n\x22,\x22dispatch-n\x22,-504469236),(function (value){\nif((!(cljs.core.sequential_QMARK_(value)))){\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: ignoring bad :dispatch-n value. Expected a collection, but got:\x22,value], 0));\n} else {\nvar seq__50208 \x3d cljs.core.seq(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,value));\nvar chunk__50209 \x3d null;\nvar count__50210 \x3d (0);\nvar i__50211 \x3d (0);\nwhile(true){\nif((i__50211 \x3c count__50210)){\nvar event \x3d chunk__50209.cljs$core$IIndexed$_nth$arity$2(null,i__50211);\nre_frame.router.dispatch(event);\n\n\nvar G__50298 \x3d seq__50208;\nvar G__50299 \x3d chunk__50209;\nvar G__50300 \x3d count__50210;\nvar G__50301 \x3d (i__50211 + (1));\nseq__50208 \x3d G__50298;\nchunk__50209 \x3d G__50299;\ncount__50210 \x3d G__50300;\ni__50211 \x3d G__50301;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50208);\nif(temp__5804__auto__){\nvar seq__50208__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50208__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50208__$1);\nvar G__50302 \x3d cljs.core.chunk_rest(seq__50208__$1);\nvar G__50303 \x3d c__5568__auto__;\nvar G__50304 \x3d cljs.core.count(c__5568__auto__);\nvar G__50305 \x3d (0);\nseq__50208 \x3d G__50302;\nchunk__50209 \x3d G__50303;\ncount__50210 \x3d G__50304;\ni__50211 \x3d G__50305;\ncontinue;\n} else {\nvar event \x3d cljs.core.first(seq__50208__$1);\nre_frame.router.dispatch(event);\n\n\nvar G__50306 \x3d cljs.core.next(seq__50208__$1);\nvar G__50307 \x3d null;\nvar G__50308 \x3d (0);\nvar G__50309 \x3d (0);\nseq__50208 \x3d G__50306;\nchunk__50209 \x3d G__50307;\ncount__50210 \x3d G__50308;\ni__50211 \x3d G__50309;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}\n}));\nre_frame.fx.reg_fx(new cljs.core.Keyword(null,\x22deregister-event-handler\x22,\x22deregister-event-handler\x22,-1096518994),(function (value){\nvar clear_event \x3d cljs.core.partial.cljs$core$IFn$_invoke$arity$2(re_frame.registrar.clear_handlers,re_frame.events.kind);\nif(cljs.core.sequential_QMARK_(value)){\nvar seq__50213 \x3d cljs.core.seq(value);\nvar chunk__50214 \x3d null;\nvar count__50215 \x3d (0);\nvar i__50216 \x3d (0);\nwhile(true){\nif((i__50216 \x3c count__50215)){\nvar event \x3d chunk__50214.cljs$core$IIndexed$_nth$arity$2(null,i__50216);\nclear_event(event);\n\n\nvar G__50311 \x3d seq__50213;\nvar G__50312 \x3d chunk__50214;\nvar G__50313 \x3d count__50215;\nvar G__50314 \x3d (i__50216 + (1));\nseq__50213 \x3d G__50311;\nchunk__50214 \x3d G__50312;\ncount__50215 \x3d G__50313;\ni__50216 \x3d G__50314;\ncontinue;\n} else {\nvar temp__5804__auto__ \x3d cljs.core.seq(seq__50213);\nif(temp__5804__auto__){\nvar seq__50213__$1 \x3d temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__50213__$1)){\nvar c__5568__auto__ \x3d cljs.core.chunk_first(seq__50213__$1);\nvar G__50316 \x3d cljs.core.chunk_rest(seq__50213__$1);\nvar G__50317 \x3d c__5568__auto__;\nvar G__50318 \x3d cljs.core.count(c__5568__auto__);\nvar G__50319 \x3d (0);\nseq__50213 \x3d G__50316;\nchunk__50214 \x3d G__50317;\ncount__50215 \x3d G__50318;\ni__50216 \x3d G__50319;\ncontinue;\n} else {\nvar event \x3d cljs.core.first(seq__50213__$1);\nclear_event(event);\n\n\nvar G__50321 \x3d cljs.core.next(seq__50213__$1);\nvar G__50322 \x3d null;\nvar G__50323 \x3d (0);\nvar G__50324 \x3d (0);\nseq__50213 \x3d G__50321;\nchunk__50214 \x3d G__50322;\ncount__50215 \x3d G__50323;\ni__50216 \x3d G__50324;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n} else {\nreturn clear_event(value);\n}\n}));\nre_frame.fx.reg_fx(new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),(function (value){\nif((!((cljs.core.deref(re_frame.db.app_db) \x3d\x3d\x3d value)))){\nreturn cljs.core.reset_BANG_(re_frame.db.app_db,value);\n} else {\nreturn null;\n}\n}));\n");
SHADOW_ENV.evalLoad("re_frame.cofx.js", true , "goog.provide(\x27re_frame.cofx\x27);\nre_frame.cofx.kind \x3d new cljs.core.Keyword(null,\x22cofx\x22,\x22cofx\x22,2013202907);\nif(cljs.core.truth_((re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1 ? re_frame.registrar.kinds.cljs$core$IFn$_invoke$arity$1(re_frame.cofx.kind) : re_frame.registrar.kinds.call(null,re_frame.cofx.kind)))){\n} else {\nthrow (new Error(\x22Assert failed: (re-frame.registrar/kinds kind)\x22));\n}\nre_frame.cofx.reg_cofx \x3d (function re_frame$cofx$reg_cofx(id,handler){\nreturn re_frame.registrar.register_handler(re_frame.cofx.kind,id,handler);\n});\nre_frame.cofx.inject_cofx \x3d (function re_frame$cofx$inject_cofx(var_args){\nvar G__49947 \x3d arguments.length;\nswitch (G__49947) {\ncase 1:\nreturn re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$cofx$coeffects_before(context){\nvar temp__5802__auto__ \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(re_frame.cofx.kind,id);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar handler \x3d temp__5802__auto__;\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),handler);\n} else {\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22No cofx handler registered for\x22,id], 0));\n}\n})], 0));\n}));\n\n(re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$2 \x3d (function (id,value){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$cofx$coeffects_before(context){\nvar temp__5802__auto__ \x3d re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$2(re_frame.cofx.kind,id);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar handler \x3d temp__5802__auto__;\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(context,new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),handler,value);\n} else {\nreturn re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22No cofx handler registered for\x22,id], 0));\n}\n})], 0));\n}));\n\n(re_frame.cofx.inject_cofx.cljs$lang$maxFixedArity \x3d 2);\n\nre_frame.cofx.reg_cofx(new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),(function re_frame$cofx$db_coeffects_handler(coeffects){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(coeffects,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),cljs.core.deref(re_frame.db.app_db));\n}));\nre_frame.cofx.inject_db \x3d re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\n");
SHADOW_ENV.evalLoad("re_frame.std_interceptors.js", true , "goog.provide(\x27re_frame.std_interceptors\x27);\nre_frame.std_interceptors.debug \x3d re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22debug\x22,\x22debug\x22,-1608172596),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$debug_before(context){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22log\x22,\x22log\x22,-1595516004),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22Handling re-frame event:\x22,re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442))], 0));\n\nreturn context;\n}),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$std_interceptors$debug_after(context){\nvar event \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nvar orig_db \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar new_db \x3d re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),new cljs.core.Keyword(\x22re-frame.std-interceptors\x22,\x22not-found\x22,\x22re-frame.std-interceptors/not-found\x22,-1614827865));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new_db,new cljs.core.Keyword(\x22re-frame.std-interceptors\x22,\x22not-found\x22,\x22re-frame.std-interceptors/not-found\x22,-1614827865))){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22log\x22,\x22log\x22,-1595516004),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22No app-db changes in:\x22,event], 0));\n} else {\nvar vec__49994_50053 \x3d clojure.data.diff(orig_db,new_db);\nvar only_before_50054 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49994_50053,(0),null);\nvar only_after_50055 \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49994_50053,(1),null);\nvar db_changed_QMARK__50056 \x3d (((!((only_before_50054 \x3d\x3d null)))) || ((!((only_after_50055 \x3d\x3d null)))));\nif(db_changed_QMARK__50056){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22group\x22,\x22group\x22,582596132),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22db clojure.data/diff for:\x22,event], 0));\n\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22log\x22,\x22log\x22,-1595516004),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22only before:\x22,only_before_50054], 0));\n\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22log\x22,\x22log\x22,-1595516004),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22only after :\x22,only_after_50055], 0));\n\nre_frame.loggers.console(new cljs.core.Keyword(null,\x22groupEnd\x22,\x22groupEnd\x22,-337721382));\n} else {\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22log\x22,\x22log\x22,-1595516004),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22No app-db changes resulted from:\x22,event], 0));\n}\n}\n\nreturn context;\n})], 0));\nre_frame.std_interceptors.unwrap \x3d re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22unwrap\x22,\x22unwrap\x22,-1399175462),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$unwrap_before(context){\nvar vec__50002 \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nvar _ \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50002,(0),null);\nvar payload \x3d cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__50002,(1),null);\nvar event \x3d vec__50002;\nif((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((2),cljs.core.count(event))) \x26\x26 (cljs.core.map_QMARK_(payload)))))){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22unwrap\\\x22 interceptor requires event to be a 2-vector of [event-id payload-map]. Got \x22,event], 0));\n\nreturn context;\n} else {\nreturn re_frame.interceptor.assoc_coeffect(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),payload);\n}\n}),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$std_interceptors$unwrap_after(context){\nreturn re_frame.interceptor.assoc_coeffect(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22original-event\x22,\x22original-event\x22,2121330403)));\n})], 0));\nre_frame.std_interceptors.trim_v \x3d re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22trim-v\x22,\x22trim-v\x22,-1274938640),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$trim_v_before(context){\nif((!(cljs.core.vector_QMARK_(re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442)))))){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22trim-v\\\x22 interceptor expected event to be a vector. Got a \x22,cljs.core.type(re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442)))], 0));\n\nreturn context;\n} else {\nreturn re_frame.interceptor.update_coeffect.cljs$core$IFn$_invoke$arity$variadic(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),cljs.core.subvec,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(1)], 0));\n}\n}),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$std_interceptors$trim_v_after(context){\nreturn re_frame.interceptor.assoc_coeffect(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22original-event\x22,\x22original-event\x22,2121330403)));\n})], 0));\n/**\n * Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n * \n *   These handlers take two arguments;  `db` and `event`, and they return `db`.\n * \n *    (fn [db event]\n *       ....)\n * \n *   So, the interceptor wraps the given handler:\n *   1. extracts two `:coeffects` keys: db and event\n *   2. calls handler-fn\n *   3. stores the db result back into context\x27s `:effects`\n */\nre_frame.std_interceptors.db_handler__GT_interceptor \x3d (function re_frame$std_interceptors$db_handler__GT_interceptor(handler_fn){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22db-handler\x22,\x22db-handler\x22,579530098),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$db_handler__GT_interceptor_$_db_handler_before(context){\nvar new_context \x3d ((re_frame.trace.is_trace_enabled_QMARK_())?(function (){var _STAR_current_trace_STAR__orig_val__50012 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__50013 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22event\x22,\x22handler\x22,\x22event/handler\x22,-295903150),new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22original-event\x22,\x22original-event\x22,2121330403))], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__50013);\n\ntry{try{var map__50016 \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context);\nvar map__50016__$1 \x3d cljs.core.__destructure_map(map__50016);\nvar db \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50016__$1,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar event \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50016__$1,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nreturn re_frame.interceptor.assoc_effect(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),(handler_fn.cljs$core$IFn$_invoke$arity$2 ? handler_fn.cljs$core$IFn$_invoke$arity$2(db,event) : handler_fn.call(null,db,event)));\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50057 \x3d re_frame.interop.now();\nvar duration__49765__auto___50058 \x3d (end__49764__auto___50057 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50058,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50057);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__50012);\n}})():(function (){var map__50017 \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context);\nvar map__50017__$1 \x3d cljs.core.__destructure_map(map__50017);\nvar db \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50017__$1,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar event \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50017__$1,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nreturn re_frame.interceptor.assoc_effect(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),(handler_fn.cljs$core$IFn$_invoke$arity$2 ? handler_fn.cljs$core$IFn$_invoke$arity$2(db,event) : handler_fn.call(null,db,event)));\n})());\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50059 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(new_context),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(new_context),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50059);\n\n} else {\n}\n\nreturn new_context;\n})], 0));\n});\n/**\n * Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n * \n *   These handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n * \n *    (fn [coeffects event]\n *       {:db ...\n *        :fx ...})\n * \n * Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n *   1. extracts `:coeffects`\n *   2. call handler-fn giving coeffects\n *   3. stores the result back into the `:effects`\n */\nre_frame.std_interceptors.fx_handler__GT_interceptor \x3d (function re_frame$std_interceptors$fx_handler__GT_interceptor(handler_fn){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22fx-handler\x22,\x22fx-handler\x22,-549783097),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$fx_handler__GT_interceptor_$_fx_handler_before(context){\nvar new_context \x3d ((re_frame.trace.is_trace_enabled_QMARK_())?(function (){var _STAR_current_trace_STAR__orig_val__50019 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__50020 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22event\x22,\x22handler\x22,\x22event/handler\x22,-295903150),new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22original-event\x22,\x22original-event\x22,2121330403))], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__50020);\n\ntry{try{var map__50024 \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context);\nvar map__50024__$1 \x3d cljs.core.__destructure_map(map__50024);\nvar coeffects \x3d map__50024__$1;\nvar event \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50024__$1,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),(handler_fn.cljs$core$IFn$_invoke$arity$2 ? handler_fn.cljs$core$IFn$_invoke$arity$2(coeffects,event) : handler_fn.call(null,coeffects,event)));\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50060 \x3d re_frame.interop.now();\nvar duration__49765__auto___50061 \x3d (end__49764__auto___50060 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50061,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50060);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__50019);\n}})():(function (){var map__50025 \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context);\nvar map__50025__$1 \x3d cljs.core.__destructure_map(map__50025);\nvar coeffects \x3d map__50025__$1;\nvar event \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50025__$1,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),(handler_fn.cljs$core$IFn$_invoke$arity$2 ? handler_fn.cljs$core$IFn$_invoke$arity$2(coeffects,event) : handler_fn.call(null,coeffects,event)));\n})());\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50062 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(new_context),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(new_context),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50062);\n\n} else {\n}\n\nreturn new_context;\n})], 0));\n});\n/**\n * Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\n *   These advanced handlers take one argument: `context` and they return a modified `context`.\n *   Example:\n * \n *    (fn [context]\n *       (enqueue context [more interceptors]))\n */\nre_frame.std_interceptors.ctx_handler__GT_interceptor \x3d (function re_frame$std_interceptors$ctx_handler__GT_interceptor(handler_fn){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22ctx-handler\x22,\x22ctx-handler\x22,-1777672230),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$ctx_handler__GT_interceptor_$_ctx_handler_before(context){\nvar new_context \x3d ((re_frame.trace.is_trace_enabled_QMARK_())?(function (){var _STAR_current_trace_STAR__orig_val__50034 \x3d re_frame.trace._STAR_current_trace_STAR_;\nvar _STAR_current_trace_STAR__temp_val__50035 \x3d re_frame.trace.start_trace(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22op-type\x22,\x22op-type\x22,-1636141668),new cljs.core.Keyword(\x22event\x22,\x22handler\x22,\x22event/handler\x22,-295903150),new cljs.core.Keyword(null,\x22operation\x22,\x22operation\x22,-1267664310),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22original-event\x22,\x22original-event\x22,2121330403))], null));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__temp_val__50035);\n\ntry{try{return (handler_fn.cljs$core$IFn$_invoke$arity$1 ? handler_fn.cljs$core$IFn$_invoke$arity$1(context) : handler_fn.call(null,context));\n}finally {if(re_frame.trace.is_trace_enabled_QMARK_()){\nvar end__49764__auto___50063 \x3d re_frame.interop.now();\nvar duration__49765__auto___50064 \x3d (end__49764__auto___50063 - new cljs.core.Keyword(null,\x22start\x22,\x22start\x22,-355208981).cljs$core$IFn$_invoke$arity$1(re_frame.trace._STAR_current_trace_STAR_));\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(re_frame.trace.traces,cljs.core.conj,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22duration\x22,\x22duration\x22,1444101068),duration__49765__auto___50064,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22end\x22,\x22end\x22,-268185958),re_frame.interop.now()], 0)));\n\nre_frame.trace.run_tracing_callbacks_BANG_(end__49764__auto___50063);\n} else {\n}\n}}finally {(re_frame.trace._STAR_current_trace_STAR_ \x3d _STAR_current_trace_STAR__orig_val__50034);\n}})():(handler_fn.cljs$core$IFn$_invoke$arity$1 ? handler_fn.cljs$core$IFn$_invoke$arity$1(context) : handler_fn.call(null,context)));\nif(re_frame.trace.is_trace_enabled_QMARK_()){\nvar new_trace__49766__auto___50065 \x3d cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.update.cljs$core$IFn$_invoke$arity$4(re_frame.trace._STAR_current_trace_STAR_,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),cljs.core.merge,new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977).cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(new_context),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context)], null)], null))),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22effects\x22,\x22effects\x22,-282369292),re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(new_context),new cljs.core.Keyword(null,\x22coeffects\x22,\x22coeffects\x22,497912985),re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context)], null)], null),new cljs.core.Keyword(null,\x22tags\x22,\x22tags\x22,1771418977))], 0));\n(re_frame.trace._STAR_current_trace_STAR_ \x3d new_trace__49766__auto___50065);\n\n} else {\n}\n\nreturn new_context;\n})], 0));\n});\nre_frame.std_interceptors.path \x3d (function re_frame$std_interceptors$path(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50066 \x3d arguments.length;\nvar i__5770__auto___50067 \x3d (0);\nwhile(true){\nif((i__5770__auto___50067 \x3c len__5769__auto___50066)){\nargs__5775__auto__.push((arguments[i__5770__auto___50067]));\n\nvar G__50068 \x3d (i__5770__auto___50067 + (1));\ni__5770__auto___50067 \x3d G__50068;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((0) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn re_frame.std_interceptors.path.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(re_frame.std_interceptors.path.cljs$core$IFn$_invoke$arity$variadic \x3d (function (args){\nvar path \x3d cljs.core.flatten(args);\nvar db_store_key \x3d new cljs.core.Keyword(\x22re-frame-path\x22,\x22db-store\x22,\x22re-frame-path/db-store\x22,655758490);\nif(cljs.core.empty_QMARK_(path)){\nre_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22error\x22,\x22error\x22,-978969032),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22path\\\x22 interceptor given no params\x22], 0));\n} else {\n}\n\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22path\x22,\x22path\x22,-188191168),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function (context){\nvar original_db \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nreturn re_frame.interceptor.assoc_coeffect(cljs.core.update.cljs$core$IFn$_invoke$arity$4(context,db_store_key,cljs.core.conj,original_db),new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(original_db,path));\n}),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function (context){\nvar db_store \x3d db_store_key.cljs$core$IFn$_invoke$arity$1(context);\nvar original_db \x3d cljs.core.peek(db_store);\nvar new_db_store \x3d cljs.core.pop(db_store);\nvar context_SINGLEQUOTE_ \x3d re_frame.interceptor.assoc_coeffect(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(context,db_store_key,new_db_store),new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),original_db);\nvar db \x3d re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),new cljs.core.Keyword(\x22re-frame.std-interceptors\x22,\x22not-found\x22,\x22re-frame.std-interceptors/not-found\x22,-1614827865));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(db,new cljs.core.Keyword(\x22re-frame.std-interceptors\x22,\x22not-found\x22,\x22re-frame.std-interceptors/not-found\x22,-1614827865))){\nreturn context_SINGLEQUOTE_;\n} else {\nreturn re_frame.interceptor.assoc_effect(context_SINGLEQUOTE_,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),cljs.core.assoc_in(original_db,path,db));\n}\n})], 0));\n}));\n\n(re_frame.std_interceptors.path.cljs$lang$maxFixedArity \x3d (0));\n\n/** @this {Function} */\n(re_frame.std_interceptors.path.cljs$lang$applyTo \x3d (function (seq50039){\nvar self__5755__auto__ \x3d this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq50039));\n}));\n\nre_frame.std_interceptors.enrich \x3d (function re_frame$std_interceptors$enrich(f){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22enrich\x22,\x22enrich\x22,-2108921925),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$std_interceptors$enrich_$_enrich_after(context){\nvar event \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\nvar prev_db \x3d ((cljs.core.contains_QMARK_(re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(context),new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759)))?re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759)):re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759)));\nvar new_db \x3d (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(prev_db,event) : f.call(null,prev_db,event));\nreturn re_frame.interceptor.assoc_effect(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),(function (){var or__5045__auto__ \x3d new_db;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn prev_db;\n}\n})());\n})], 0));\n});\nre_frame.std_interceptors.after \x3d (function re_frame$std_interceptors$after(f){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$std_interceptors$after_$_after_after(context){\nvar db \x3d ((cljs.core.contains_QMARK_(re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(context),new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759)))?re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759)):re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759)));\nvar event \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22event\x22,\x22event\x22,301435442));\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(db,event) : f.call(null,db,event));\n\nreturn context;\n})], 0));\n});\nre_frame.std_interceptors.on_changes \x3d (function re_frame$std_interceptors$on_changes(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50069 \x3d arguments.length;\nvar i__5770__auto___50070 \x3d (0);\nwhile(true){\nif((i__5770__auto___50070 \x3c len__5769__auto___50069)){\nargs__5775__auto__.push((arguments[i__5770__auto___50070]));\n\nvar G__50071 \x3d (i__5770__auto___50070 + (1));\ni__5770__auto___50070 \x3d G__50071;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((2) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn re_frame.std_interceptors.on_changes.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(re_frame.std_interceptors.on_changes.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,out_path,in_paths){\nreturn re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22on-changes\x22,\x22on-changes\x22,1345912602),new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914),(function re_frame$std_interceptors$on_change_after(context){\nvar new_db \x3d re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar old_db \x3d re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nvar new_ins \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__50047_SHARP_){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(new_db,p1__50047_SHARP_);\n}),in_paths);\nvar old_ins \x3d cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__50048_SHARP_){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(old_db,p1__50048_SHARP_);\n}),in_paths);\nvar changed_ins_QMARK_ \x3d (function (){var and__5043__auto__ \x3d cljs.core.contains_QMARK_(re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(context),new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759));\nif(and__5043__auto__){\nreturn cljs.core.some(cljs.core.false_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$3(cljs.core.identical_QMARK_,new_ins,old_ins));\n} else {\nreturn and__5043__auto__;\n}\n})();\nif(cljs.core.truth_(changed_ins_QMARK_)){\nreturn re_frame.interceptor.assoc_effect(context,new cljs.core.Keyword(null,\x22db\x22,\x22db\x22,993250759),cljs.core.assoc_in(new_db,out_path,cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,new_ins)));\n} else {\nreturn context;\n}\n})], 0));\n}));\n\n(re_frame.std_interceptors.on_changes.cljs$lang$maxFixedArity \x3d (2));\n\n/** @this {Function} */\n(re_frame.std_interceptors.on_changes.cljs$lang$applyTo \x3d (function (seq50049){\nvar G__50050 \x3d cljs.core.first(seq50049);\nvar seq50049__$1 \x3d cljs.core.next(seq50049);\nvar G__50051 \x3d cljs.core.first(seq50049__$1);\nvar seq50049__$2 \x3d cljs.core.next(seq50049__$1);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__50050,G__50051,seq50049__$2);\n}));\n\n/**\n * An interceptor which adds registered global interceptors to the context\x27s queue.\n * \n * NOTE: :queue is a Clojure.lang.PersistentQueue and not a vector.\n */\nre_frame.std_interceptors.inject_global_interceptors \x3d re_frame.interceptor.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092),new cljs.core.Keyword(null,\x22inject-global-interceptors\x22,\x22inject-global-interceptors\x22,-2144129737),new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388),(function re_frame$std_interceptors$inject_global_interceptors_before(context){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(context,new cljs.core.Keyword(null,\x22queue\x22,\x22queue\x22,1455835879),(function (p1__50052_SHARP_){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(re_frame.settings.get_global_interceptors(),p1__50052_SHARP_);\n}));\n})], 0));\n");
SHADOW_ENV.evalLoad("re_frame.core.js", true , "goog.provide(\x27re_frame.core\x27);\n/**\n * Queue `event` for processing (handling).\n * \n *   `event` is a vector and the first element is typically a keyword\n *   which identifies the kind of event.\n * \n *   The event will be added to a FIFO processing queue, so event\n *   handling does not happen immediately. It will happen \x27very soon\x27\n *   but not now. And if the queue already contains events, they\n *   will be processed first.\n * \n *   Usage:\n * \n *    #!clj\n *    (dispatch [:order \x22pizza\x22 {:supreme 2 :meatlovers 1 :veg 1}])\n *   \n */\nre_frame.core.dispatch \x3d (function re_frame$core$dispatch(event){\nreturn re_frame.router.dispatch(event);\n});\n/**\n * Synchronously (immediately) process `event`. It does **not** queue\n *   the event for handling later as `dispatch` does.\n * \n *   `event` is a vector and the first element is typically a keyword\n *   which identifies the kind of event.\n * \n *   It is an error to use `dispatch-sync` within an event handler because\n *   you can\x27t immediately process an new event when one is already\n *   part way through being processed.\n * \n *   Generally, avoid using this function, and instead, use `dispatch`.\n *   Only use it in the narrow set of cases where any delay in\n *   processing is a problem:\n * \n *  1. the `:on-change` handler of a text field where we are expecting fast typing\n *  2. when initialising your app - see \x27main\x27 in examples/todomvc/src/core.cljs\n *  3. in a unit test where immediate, synchronous processing is useful\n * \n *   Usage:\n * \n *    #!clj\n *    (dispatch-sync [:sing :falsetto \x22piano accordion\x22])\n *   \n */\nre_frame.core.dispatch_sync \x3d (function re_frame$core$dispatch_sync(event){\nreturn re_frame.router.dispatch_sync(event);\n});\n/**\n * Register the given event `handler` (function) for the given `id`. Optionally, provide\n *   an `interceptors` chain:\n * \n *  - `id` is typically a namespaced keyword  (but can be anything)\n *  - `handler` is a function: (db event) -\x3e db\n *  - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n * \n *   Example Usage:\n * \n *    #!clj\n *    (reg-event-db\n *      :token\n *      (fn [db event]\n *        (assoc db :some-key (get event 2)))  ;; return updated db\n * \n *   Or perhaps:\n * \n *    #!clj\n *    (reg-event-db\n *      :namespaced/id           ;; \x3c-- namespaced keywords are often used\n *      [one two three]          ;; \x3c-- a seq of interceptors\n *      (fn [db [_ arg1 arg2]]   ;; \x3c-- event vector is destructured\n *        (-\x3e db\n *          (dissoc arg1)\n *          (update :key + arg2))))   ;; return updated db\n *   \n */\nre_frame.core.reg_event_db \x3d (function re_frame$core$reg_event_db(var_args){\nvar G__50346 \x3d arguments.length;\nswitch (G__50346) {\ncase 2:\nreturn re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$2 \x3d (function (id,handler){\nreturn re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3(id,null,handler);\n}));\n\n(re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3 \x3d (function (id,interceptors,handler){\nreturn re_frame.events.register(id,new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [re_frame.cofx.inject_db,re_frame.fx.do_fx,re_frame.std_interceptors.inject_global_interceptors,interceptors,re_frame.std_interceptors.db_handler__GT_interceptor(handler)], null));\n}));\n\n(re_frame.core.reg_event_db.cljs$lang$maxFixedArity \x3d 3);\n\n/**\n * Register the given event `handler` (function) for the given `id`. Optionally, provide\n *   an `interceptors` chain:\n * \n *  - `id` is typically a namespaced keyword  (but can be anything)\n *  - `handler` is a function: (coeffects-map event-vector) -\x3e effects-map\n *  - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n * \n * \n *   Example Usage:\n * \n *    #!clj\n *    (reg-event-fx\n *      :event-id\n *      (fn [cofx event]\n *        {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\n * \n * \n *   Or perhaps:\n * \n *    #!clj\n *    (reg-event-fx\n *      :namespaced/id           ;; \x3c-- namespaced keywords are often used\n *      [one two three]          ;; \x3c-- a seq of interceptors\n *      (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\n *        {:db (assoc db :some-key arg1)          ;; return a map of effects\n *         :fx [[:dispatch [:some-event arg2]]]}))\n *   \n */\nre_frame.core.reg_event_fx \x3d (function re_frame$core$reg_event_fx(var_args){\nvar G__50352 \x3d arguments.length;\nswitch (G__50352) {\ncase 2:\nreturn re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$2 \x3d (function (id,handler){\nreturn re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3(id,null,handler);\n}));\n\n(re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3 \x3d (function (id,interceptors,handler){\nreturn re_frame.events.register(id,new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [re_frame.cofx.inject_db,re_frame.fx.do_fx,re_frame.std_interceptors.inject_global_interceptors,interceptors,re_frame.std_interceptors.fx_handler__GT_interceptor(handler)], null));\n}));\n\n(re_frame.core.reg_event_fx.cljs$lang$maxFixedArity \x3d 3);\n\n/**\n * Register the given event `handler` (function) for the given `id`. Optionally, provide\n *   an `interceptors` chain:\n * \n *  - `id` is typically a namespaced keyword  (but can be anything)\n *  - `handler` is a function: context-map -\x3e context-map\n * \n *   You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\n * \n *   Example Usage:\n * \n *    #!clj\n *    (reg-event-ctx\n *      :event-id\n *      (fn [{:keys [coeffects] :as context}]\n *        (let [initial  {:db     (:db coeffects)\n *                        :event  (:event coeffects)\n *                        :fx     []}\n *              result   (-\x3e initial\n *                           function1\n *                           function2\n *                           function3)\n *              effects  (select-keys result [:db :fx])]\n *           (assoc context :effects effects))))\n *   \n */\nre_frame.core.reg_event_ctx \x3d (function re_frame$core$reg_event_ctx(var_args){\nvar G__50356 \x3d arguments.length;\nswitch (G__50356) {\ncase 2:\nreturn re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$2 \x3d (function (id,handler){\nreturn re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3(id,null,handler);\n}));\n\n(re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3 \x3d (function (id,interceptors,handler){\nreturn re_frame.events.register(id,new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [re_frame.cofx.inject_db,re_frame.fx.do_fx,re_frame.std_interceptors.inject_global_interceptors,interceptors,re_frame.std_interceptors.ctx_handler__GT_interceptor(handler)], null));\n}));\n\n(re_frame.core.reg_event_ctx.cljs$lang$maxFixedArity \x3d 3);\n\n/**\n * Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\n * \n *   When called with no args, it will unregister all currently registered event handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   event handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n */\nre_frame.core.clear_event \x3d (function re_frame$core$clear_event(var_args){\nvar G__50358 \x3d arguments.length;\nswitch (G__50358) {\ncase 0:\nreturn re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.events.kind);\n}));\n\n(re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.events.kind,id);\n}));\n\n(re_frame.core.clear_event.cljs$lang$maxFixedArity \x3d 1);\n\n/**\n * A call to `reg-sub` associates a `query-id` WITH two functions.\n * \n *   The two functions provide \x27a mechanism\x27 for creating a node\n *   in the Signal Graph. When a node of type `query-id` is needed,\n *   the two functions can be used to create it.\n * \n *   The three arguments are:\n * \n *  - `query-id` - typically a namespaced keyword (later used in subscribe)\n *  - optionally, an `input signals` function which returns the input data\n *    flows required by this kind of node.\n *  - a `computation function` which computes the value (output) of the\n *    node (from the input data flows)\n * \n *   Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\n *   will trigger the need for a new `:sub-id` Signal Graph node (matching the\n *   query `[:sub-id 3 :blue]`). And, to create that node the two functions\n *   associated with `:sub-id` will be looked up and used.\n * \n *   Just to be clear: calling `reg-sub` does not immediately create a node.\n *   It only registers \x27a mechanism\x27 (the two functions) by which nodes\n *   can be created later, when a node is bought into existence by the\n *   use of `subscribe` in a `View Function`.\n * \n *   `reg-sub` arguments are:\n * \n *  - a `query-id` (typically a namespaced keyword)\n *  - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\n *  - a function which computes the value of this kind of node (can be supplied in one of three ways)\n * \n *   The `computation function` is always the last argument supplied and has three ways to be called.\n *   Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\n * \n *   1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\n *   standard way to provide a `computation-function`\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          (fn [input-values query-vector]\n *            (:foo input-values)))\n * \n *   2. A single sugary tuple of `:-\x3e` and a 1-arity `computation-function`:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :-\x3e computation-fn)\n * \n *    This sugary variation allows you to pass a function that will expect only one parameter,\n *    namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\n *    expects two parameters which can cause unfortunate results when attempting to use\n *    clojure standard library functions, or other functions, in a functional manner.\n * \n *    For example, a significant number of subscriptions exist only to get a value\n *    from the `input-values`. As shown below, this subscription will simply retrieve\n *    the value associated with the `:foo` key in our db:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          (fn [db _]    ;; :\x3c---- trivial boilerplate we might want to skip over\n *            (:foo db)))\n * \n *    This is slightly more boilerplate than we might like to do,\n *    as we can use a keyword directly as a function, and we might like to do this:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :foo)  ;; :\x3c---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\n * \n *    By using `:-\x3e` our function would not contain the `query-vector`, and any\n *    missing keys would be represented as such:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :-\x3e :foo)\n * \n *    This form allows us to ignore the `query-vector` if our `computation-function`\n *    has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\n *    and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\n * \n *   3. A single sugary tuple of `:\x3d\x3e` and a multi-arity `computation-function`\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :\x3d\x3e computation-fn)\n * \n *    The `query-vector` can be broken into two components `[query-id \x26 optional-values]`, and\n *    some subscriptions require the `optional-values` for extra work within the subscription.\n *    To use them in variation #1, we need to destructure our `computation-function` parameters\n *    in order to use them.\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          (fn [db [_ foo]]\n *            [db foo]))\n * \n *    Again we are writing boilerplate just to reach our values, and we might prefer to\n *    have direction access through a parameter vector like `[input-values optional-values]`\n *    instead, so we might be able to use a multi-arity function directly as our `computation-function`.\n *    A rewrite of the above sub using this sugary syntax would look like this:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :\x3d\x3e vector)  ;; :\x3c---- Could also be `(fn [db foo] [db foo])`\n * \n *   The `computation function` is expected to take two arguments:\n * \n *  - `input-values` - the values which flow into this node (how is it wired into the graph?)\n *  - `query-vector` - the vector given to `subscribe`\n * \n *   and it returns a computed value (which then becomes the output of the node)\n * \n *   When `computation function` is called, the 2nd `query-vector` argument will be that\n *   vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\n *   then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\n * \n *   The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\n *   can vary in 3 ways, but whatever is there defines the `input signals` part\n *   of `the mechanism`, specifying what input values \x22flow into\x22 the\n *   `computation function` (as the 1st argument) when it is called.\n * \n *   So, `reg-sub` can be called in one of three ways, because there are three ways\n *   to define the input signals part. But note, the 2nd method, in which a\n *   `signals function` is explicitly supplied, is the most canonical and\n *   instructive. The other two are really just sugary variations.\n * \n *   **First variation** - no input signal function given:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n * \n *   In the absence of an explicit `signals function`, the node\x27s input signal defaults to `app-db`\n *   and, as a result, the value within `app-db` (a map) is\n *   given as the 1st argument when `a-computation-fn` is called.\n * \n * \n *   **Second variation** - a signal function is explicitly supplied:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      signal-fn     ;; \x3c-- here\n *      computation-fn)\n * \n *   This is the most canonical and instructive of the three variations.\n * \n *   When a node is created from the template, the `signal function` will be called and it\n *   is expected to return the input signal(s) as either a singleton, if there is only\n *   one, or a sequence if there are many, or a map with the signals as the values.\n * \n *   The current values of the returned signals will be supplied as the 1st argument to\n *   the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\n *   this value will be either a singleton, sequence or map of them (paralleling\n *   the structure returned by the `signal function`).\n * \n *   This example `signal function` returns a 2-vector of input signals.\n * \n *    #!clj\n *    (fn [query-vec dynamic-vec]\n *       [(subscribe [:a-sub])\n *        (subscribe [:b-sub])])\n * \n *   The associated computation function must be written\n *   to expect a 2-vector of values for its first argument:\n * \n *    #!clj\n *    (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n *      ....)\n * \n *   If, on the other hand, the signal function was simpler and returned a singleton, like this:\n * \n *    #!clj\n *    (fn [query-vec dynamic-vec]\n *      (subscribe [:a-sub]))      ;; \x3c-- returning a singleton\n * \n *   then the associated computation function must be written to expect a single value\n *   as the 1st argument:\n * \n *    #!clj\n *    (fn [a query-vec]       ;; 1st argument is a single value\n *       ...)\n * \n *   Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n * \n *   is the equivalent of using this\n *   2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      (fn [_ _]  re-frame/app-db)   ;; \x3c--- explicit signal-fn\n *      a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n * \n *   **Third variation** - syntax Sugar\n * \n *    #!clj\n *    (reg-sub\n *      :a-b-sub\n *      :\x3c- [:a-sub]\n *      :\x3c- [:b-sub]\n *      (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n *        {:a a :b b}))\n * \n *   This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n *   `signals-fn` you provide one or more pairs of `:\x3c-` and a subscription vector.\n * \n *   If you supply only one pair a singleton will be supplied to the computation function,\n *   as if you had supplied a `signal-fn` returning only a single value:\n * \n *    #!clj\n *    (reg-sub\n *      :a-sub\n *      :\x3c- [:a-sub]\n *      (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n *        ...))\n * \n *   Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\n *   and the direction of arrows shows the flow of data and functions. The example from\n *   directly above is reproduced here:\n * \n *    #!clj\n *    (reg-sub\n *      :a-b-sub\n *      :\x3c- [:a-sub]\n *      :\x3c- [:b-sub]\n *      :-\x3e (partial zipmap [:a :b]))\n * \n *   For further understanding, read the tutorials, and look at the detailed comments in\n *   /examples/todomvc/src/subs.cljs.\n * \n *   See also: `subscribe`\n *   \n */\nre_frame.core.reg_sub \x3d (function re_frame$core$reg_sub(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50466 \x3d arguments.length;\nvar i__5770__auto___50467 \x3d (0);\nwhile(true){\nif((i__5770__auto___50467 \x3c len__5769__auto___50466)){\nargs__5775__auto__.push((arguments[i__5770__auto___50467]));\n\nvar G__50468 \x3d (i__5770__auto___50467 + (1));\ni__5770__auto___50467 \x3d G__50468;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((1) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((1)),(0),null)):null);\nreturn re_frame.core.reg_sub.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5776__auto__);\n});\n\n(re_frame.core.reg_sub.cljs$core$IFn$_invoke$arity$variadic \x3d (function (query_id,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(re_frame.subs.reg_sub,query_id,args);\n}));\n\n(re_frame.core.reg_sub.cljs$lang$maxFixedArity \x3d (1));\n\n/** @this {Function} */\n(re_frame.core.reg_sub.cljs$lang$applyTo \x3d (function (seq50363){\nvar G__50364 \x3d cljs.core.first(seq50363);\nvar seq50363__$1 \x3d cljs.core.next(seq50363);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__50364,seq50363__$1);\n}));\n\n/**\n * Given a `query` vector, returns a Reagent `reaction` which will, over\n *   time, reactively deliver a stream of values. So, in FRP-ish terms,\n *   it returns a `Signal`.\n * \n *   To obtain the current value from the Signal, it must be dereferenced:\n * \n *    #!clj\n *    (let [signal (subscribe [:items])\n *          value  (deref signal)]     ;; could be written as @signal\n *      ...)\n * \n * which is typically written tersely as simple:\n * \n *    #!clj\n *    (let [items  @(subscribe [:items])]\n *      ...)\n * \n * \n *   `query` is a vector of at least one element. The first element is the\n *   `query-id`, typically a namespaced keyword. The rest of the vector\x27s\n *   elements are optional, additional values which parameterise the query\n *   performed.\n * \n *   `dynv` is an optional 3rd argument, which is a vector of further input\n *   signals (atoms, reactions, etc), NOT values. This argument exists for\n *   historical reasons and is borderline deprecated these days.\n * \n *   **Example Usage**:\n * \n *    #!clj\n *    (subscribe [:items])\n *    (subscribe [:items \x22blue\x22 :small])\n *    (subscribe [:items {:colour \x22blue\x22  :size :small}])\n * \n *   Note: for any given call to `subscribe` there must have been a previous call\n *   to `reg-sub`, registering the query handler (functions) associated with\n *   `query-id`.\n * \n *   **Hint**\n * \n *   When used in a view function BE SURE to `deref` the returned value.\n *   In fact, to avoid any mistakes, some prefer to define:\n * \n *    #!clj\n *    (def \x3csub  (comp deref re-frame.core/subscribe))\n * \n *   And then, within their views, they call  `(\x3csub [:items :small])` rather\n *   than using `subscribe` directly.\n * \n *   **De-duplication**\n * \n *   Two, or more, concurrent subscriptions for the same query will\n *   source reactive updates from the one executing handler.\n * \n *   See also: `reg-sub`\n *   \n */\nre_frame.core.subscribe \x3d (function re_frame$core$subscribe(var_args){\nvar G__50366 \x3d arguments.length;\nswitch (G__50366) {\ncase 1:\nreturn re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$1 \x3d (function (query){\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$1(query);\n}));\n\n(re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$2 \x3d (function (query,dynv){\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$2(query,dynv);\n}));\n\n(re_frame.core.subscribe.cljs$lang$maxFixedArity \x3d 2);\n\n/**\n * Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\n * \n *   When called with no args, it will unregister all currently registered subscription handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   subscription handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n * \n *   NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards\n */\nre_frame.core.clear_sub \x3d (function re_frame$core$clear_sub(var_args){\nvar G__50369 \x3d arguments.length;\nswitch (G__50369) {\ncase 0:\nreturn re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.subs.kind);\n}));\n\n(re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$1 \x3d (function (query_id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.subs.kind,query_id);\n}));\n\n(re_frame.core.clear_sub.cljs$lang$maxFixedArity \x3d 1);\n\n/**\n * This is a low level, advanced function.  You should probably be\n *   using `reg-sub` instead.\n * \n *   Some explanation is available in the docs at\n *   \x3ca href\x3d\x22http://day8.github.io/re-frame/flow-mechanics/\x22 target\x3d\x22_blank\x22\x3ehttp://day8.github.io/re-frame/flow-mechanics/\x3c/a\x3e\n */\nre_frame.core.reg_sub_raw \x3d (function re_frame$core$reg_sub_raw(query_id,handler_fn){\nreturn re_frame.registrar.register_handler(re_frame.subs.kind,query_id,handler_fn);\n});\n/**\n * Removes all subscriptions from the cache.\n * \n *   This function can be used at development time or test time. Useful when hot reloading\n *   namespaces containing subscription handlers. Also call it after a React/render exception,\n *   because React components won\x27t have been cleaned up properly. And this, in turn, means\n *   the subscriptions within those components won\x27t have been cleaned up correctly. So this\n *   forces the issue.\n *   \n */\nre_frame.core.clear_subscription_cache_BANG_ \x3d (function re_frame$core$clear_subscription_cache_BANG_(){\nreturn re_frame.subs.clear_subscription_cache_BANG_();\n});\n/**\n * Register the given effect `handler` for the given `id`:\n * \n *  - `id` is keyword, often namespaced.\n *  - `handler` is a side-effecting function which takes a single argument and whose return\n *    value is ignored.\n * \n *   To use, first, associate `:effect2` with a handler:\n * \n *    #!clj\n *    (reg-fx\n *       :effect2\n *       (fn [value]\n *          ... do something side-effect-y))\n * \n *   Then, later, if an event handler were to return this effects map:\n * \n *    #!clj\n *    {:effect2  [1 2]}\n * \n *   then the `handler` `fn` we registered previously, using `reg-fx`, will be\n *   called with an argument of `[1 2]`.\n *   \n */\nre_frame.core.reg_fx \x3d (function re_frame$core$reg_fx(id,handler){\nreturn re_frame.fx.reg_fx(id,handler);\n});\n/**\n * Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\n * \n *   When called with no args, it will unregister all currently registered effect handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   effect handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n *   \n */\nre_frame.core.clear_fx \x3d (function re_frame$core$clear_fx(var_args){\nvar G__50377 \x3d arguments.length;\nswitch (G__50377) {\ncase 0:\nreturn re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.fx.kind);\n}));\n\n(re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.fx.kind,id);\n}));\n\n(re_frame.core.clear_fx.cljs$lang$maxFixedArity \x3d 1);\n\n/**\n * Register the given coeffect `handler` for the given `id`, for later use\n *   within `inject-cofx`:\n * \n *  - `id` is keyword, often namespaced.\n *  - `handler` is a function which takes either one or two arguments, the first of which is\n *     always `coeffects` and which returns an updated `coeffects`.\n * \n *   See also: `inject-cofx`\n *   \n */\nre_frame.core.reg_cofx \x3d (function re_frame$core$reg_cofx(id,handler){\nreturn re_frame.cofx.reg_cofx(id,handler);\n});\n/**\n * Given an `id`, and an optional, arbitrary `value`, returns an interceptor\n *   whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n *   \x27coeffect handler\x27 identified by the `id`.\n * \n *   The previous association of a `coeffect handler` with an `id` will have\n *   happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n * \n *   Within the created interceptor, this \x27looked up\x27 `coeffect handler` will\n *   be called (within the `:before`) with two arguments:\n * \n *   - the current value of `:coeffects`\n *   - optionally, the originally supplied arbitrary `value`\n * \n *   This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n * \n *   **Example of `inject-cofx` and `reg-cofx` working together**\n * \n * \n *   First - Early in app startup, you register a `coeffect handler` for `:datetime`:\n * \n *    #!clj\n *    (re-frame.core/reg-cofx\n *      :datetime                        ;; usage  (inject-cofx :datetime)\n *      (fn coeffect-handler\n *        [coeffect]\n *        (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n * \n *   Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n * \n *    #!clj\n *    (re-frame.core/reg-event-fx            ;; when registering an event handler\n *      :event-id\n *      [ ... (inject-cofx :datetime) ... ]  ;; \x3c-- create an injecting interceptor\n *      (fn event-handler\n *        [coeffect event]\n *          ;;... in here can access (:now coeffect) to obtain current datetime ...\n *        )))\n * \n *   **Background**\n * \n *   `coeffects` are the input resources required by an event handler\n *   to perform its job. The two most obvious ones are `db` and `event`.\n *   But sometimes an event handler might need other resources.\n * \n *   Perhaps an event handler needs a random number or a GUID or the current\n *   datetime. Perhaps it needs access to a DataScript database connection.\n * \n *   If an event handler directly accesses these resources, it stops being\n *   pure and, consequently, it becomes harder to test, etc. So we don\x27t\n *   want that.\n * \n *   Instead, the interceptor created by this function is a way to \x27inject\x27\n *   \x27necessary resources\x27 into the `:coeffects` (map) subsequently given\n *   to the event handler at call time.\n * \n *   See also `reg-cofx`\n *   \n */\nre_frame.core.inject_cofx \x3d (function re_frame$core$inject_cofx(var_args){\nvar G__50379 \x3d arguments.length;\nswitch (G__50379) {\ncase 1:\nreturn re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$1(id);\n}));\n\n(re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$2 \x3d (function (id,value){\nreturn re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$2(id,value);\n}));\n\n(re_frame.core.inject_cofx.cljs$lang$maxFixedArity \x3d 2);\n\n/**\n * Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\n * \n *   When called with no args, it will unregister all currently registered coeffect handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   coeffect handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n */\nre_frame.core.clear_cofx \x3d (function re_frame$core$clear_cofx(var_args){\nvar G__50387 \x3d arguments.length;\nswitch (G__50387) {\ncase 0:\nreturn re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.cofx.kind);\n}));\n\n(re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.cofx.kind,id);\n}));\n\n(re_frame.core.clear_cofx.cljs$lang$maxFixedArity \x3d 1);\n\n/**\n * An interceptor which logs/instruments an event handler\x27s actions to\n *   `js/console.debug`. See examples/todomvc/src/events.cljs for use.\n * \n *   Output includes:\n * \n *  1. the event vector\n *  2. a `clojure.data/diff` of db, before vs after, which shows\n *     the changes caused by the event handler. To understand the output,\n *     you should understand:\n *     \x3ca href\x3d\x22https://clojuredocs.org/clojure.data/diff\x22 target\x3d\x22_blank\x22\x3ehttps://clojuredocs.org/clojure.data/diff\x3c/a\x3e.\n * \n *   You\x27d typically include this interceptor after (to the right of) any\n *   `path` interceptor.\n * \n *   Warning:  calling `clojure.data/diff` on large, complex data structures\n *   can be slow. So, you won\x27t want this interceptor present in production\n *   code. So, you should condition it out like this:\n * \n *    #!clj\n *    (re-frame.core/reg-event-db\n *      :evt-id\n *      [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; \x3c-- conditional\n *      (fn [db v]\n *         ...))\n * \n *   To make this code fragment work, you\x27ll also have to set `goog.DEBUG` to\n *   `false` in your production builds. For an example, look in `project.clj` of /examples/todomvc.\n *   \n */\nre_frame.core.debug \x3d re_frame.std_interceptors.debug;\n/**\n * Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\n *   the event handler is given a specific part of `app-db` to change, not all of `app-db`.\n * \n *   The interceptor has both a `:before` and `:after` functions. The `:before` replaces\n *   the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\n *   and it grafts the handler\x27s return value back into db, at the right path.\n * \n *   Examples:\n * \n *    #!clj\n *    (path :some :path)\n *    (path [:some :path])\n *    (path [:some :path] :to :here)\n *    (path [:some :path] [:to] :here)\n * \n *   Example Use:\n * \n *    #!clj\n *    (reg-event-db\n *      :event-id\n *      (path [:a :b])  ;; \x3c-- used here, in interceptor chain\n *      (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\n *        ... new-b))   ;; returns a new value for that path (not the entire db)\n * \n *   Notes:\n * \n *  1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n *  2. if `:effects` contains no `:db` effect, can\x27t graft a value back in.\n *   \n */\nre_frame.core.path \x3d (function re_frame$core$path(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50474 \x3d arguments.length;\nvar i__5770__auto___50475 \x3d (0);\nwhile(true){\nif((i__5770__auto___50475 \x3c len__5769__auto___50474)){\nargs__5775__auto__.push((arguments[i__5770__auto___50475]));\n\nvar G__50476 \x3d (i__5770__auto___50475 + (1));\ni__5770__auto___50475 \x3d G__50476;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((0) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.path.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(re_frame.core.path.cljs$core$IFn$_invoke$arity$variadic \x3d (function (args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(re_frame.std_interceptors.path,args);\n}));\n\n(re_frame.core.path.cljs$lang$maxFixedArity \x3d (0));\n\n/** @this {Function} */\n(re_frame.core.path.cljs$lang$applyTo \x3d (function (seq50390){\nvar self__5755__auto__ \x3d this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq50390));\n}));\n\n/**\n * Returns an interceptor which will run the given function `f` in the `:after`\n *   position.\n * \n *   `f` is called with two arguments: `db` and `event`, and is expected to\n *   return a modified `db`.\n * \n *   Unlike the `after` interceptor which is only about side effects, `enrich`\n *   expects `f` to process and alter the given `db` coeffect in some useful way,\n *   contributing to the derived data, flowing vibe.\n * \n *   If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\n * \n *   #### Example Use:\n * \n *   Imagine that todomvc needed to do duplicate detection - if any two todos had\n *   the same text, then highlight their background, and report them via a warning\n *   at the bottom of the panel.\n * \n *   Almost any user action (edit text, add new todo, remove a todo) requires a\n *   complete reassessment of duplication errors and warnings. E.g. that edit\n *   just made might have introduced a new duplicate, or removed one. Same with\n *   any todo removal. So we need to re-calculate warnings after any CRUD events\n *   associated with the todos list.\n * \n *   Unless we are careful, we might end up coding subtly different checks\n *   for each kind of CRUD operation.  The duplicates check made after\n *   \x27delete todo\x27 event might be subtly different to that done after an\n *   editing operation. Nice and efficient, but fiddly. A bug generator\n *   approach.\n * \n *   So, instead, we create an `f` which recalculates ALL warnings from scratch\n *   every time there is ANY change. It will inspect all the todos, and\n *   reset ALL FLAGS every time (overwriting what was there previously)\n *   and fully recalculate the list of duplicates (displayed at the bottom?).\n * \n *   \x3ca href\x3d\x22https://twitter.com/nathanmarz/status/879722740776939520\x22 target\x3d\x22_blank\x22\x3ehttps://twitter.com/nathanmarz/status/879722740776939520\x3c/a\x3e\n * \n *   By applying `f` in an `:enrich` interceptor, after every CRUD event,\n *   we keep the handlers simple and yet we ensure this important step\n *   (of getting warnings right) is not missed on any change.\n * \n *   We can test `f` easily - it is a pure function - independently of\n *   any CRUD operation.\n * \n *   This brings huge simplicity at the expense of some re-computation\n *   each time. This may be a very satisfactory trade-off in many cases.\n * \n *   #### Returning nil\n * \n *   In some cases, it\x27s useful to apply a change to specific situations that can\n *   be determined at runtime instead of when defining the handler with an\n *   `:enrich` interceptor. Instead of forcing you to return the `db` from every\n *   non-applicable branch, you can return `nil` to use the given `db` value:\n * \n *    #!clj\n *    (def set-last-update\n *      (core/enrich\n *        (fn [{db :db} [_ {user :user}]]\n *          (when (active-user? user)  ;; \x3c- Only perform an update if user is active\n *            ...))))\n *   \n */\nre_frame.core.enrich \x3d (function re_frame$core$enrich(f){\nreturn re_frame.std_interceptors.enrich(f);\n});\n/**\n * \x3e New in v1.2.0\n * \n * An interceptor which decreases the amount of destructuring necessary in an\n * event handler where the event is structured as a 2-vector of\n * [event-id payload-map].\n * \n * It promotes the `payload-map` part to be the event ultimately given to the\n * event handler. Should you want the full original event, it can be found in\n * `coeffects` under the key `:original-event`.\n * \n * If a dispatch looked like this:\n * \n *    #!clj\n *     (dispatch [:event-id {:x 1 :y 2 :z 3}])\n * \n * Your event handlers can look like this:\n * \n *    #!clj\n *     (reg-event-fx\n *       :event-id\n *       [... unwrap ...]                    ;; \x3c-- added to the interceptors\n *       (fn [{:keys [db]} {:keys [x y z]}]  ;; \x3c-- instead of [_ {:keys [x y z]}]\n *         ...)\n * \n */\nre_frame.core.unwrap \x3d re_frame.std_interceptors.unwrap;\n/**\n * An interceptor which removes the first element of the event vector,\n *   before it is supplied to the event handler, allowing you to write more\n * aesthetically pleasing event handlers. No leading underscore on the event-v!\n * \n *   Should you want the full original event, it can be found in `coeffects` under\n *   the key `:original-event`.\n * \n *   Your event handlers will look like this:\n * \n *    #!clj\n *    (reg-event-db\n *      :event-id\n *      [... trim-v ...]    ;; \x3c-- added to the interceptors\n *      (fn [db [x y z]]    ;; \x3c-- instead of [_ x y z]\n *        ...)\n *  \n */\nre_frame.core.trim_v \x3d re_frame.std_interceptors.trim_v;\n/**\n * Returns an interceptor which runs the given function `f` in the `:after`\n *   position, presumably for side effects.\n * \n *   `f` is called with two arguments: the `:effects` value for `:db`\n *   (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\n *   Its return value is ignored, so `f` can only side-effect.\n * \n *   An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\n * \n *   - `f` runs schema validation (reporting any errors found).\n *   - `f` writes to localstorage.\n */\nre_frame.core.after \x3d (function re_frame$core$after(f){\nreturn re_frame.std_interceptors.after(f);\n});\n/**\n * Returns an interceptor which will observe N paths within `db`, and if any of them\n *   test not `identical?` to their previous value  (as a result of a event handler\n *   being run), then it will run `f` to compute a new value, which is then assoc-ed\n *   into the given `out-path` within `db`.\n * \n *   Example Usage:\n * \n *    #!clj\n *    (defn my-f\n *      [a-val b-val]\n *      ... some computation on a and b in here)\n * \n *    ;; use it\n *    (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\n * \n *    (reg-event-db\n *      :event-id\n *      [... my-interceptor ...]  ;; \x3c-- ultimately used here\n *      (fn [db v]\n *         ...))\n * \n * \n *   If you put this interceptor on handlers which might change paths `:a` or `:b`,\n *   it will:\n * \n *  - call `f` each time the value at path `[:a]` or `[:b]` changes\n *  - call `f` with the values extracted from `[:a]` `[:b]`\n *  - assoc the return value from `f` into the path  `[:c]`\n *   \n */\nre_frame.core.on_changes \x3d (function re_frame$core$on_changes(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50480 \x3d arguments.length;\nvar i__5770__auto___50481 \x3d (0);\nwhile(true){\nif((i__5770__auto___50481 \x3c len__5769__auto___50480)){\nargs__5775__auto__.push((arguments[i__5770__auto___50481]));\n\nvar G__50482 \x3d (i__5770__auto___50481 + (1));\ni__5770__auto___50481 \x3d G__50482;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((2) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn re_frame.core.on_changes.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(re_frame.core.on_changes.cljs$core$IFn$_invoke$arity$variadic \x3d (function (f,out_path,in_paths){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(re_frame.std_interceptors.on_changes,f,out_path,in_paths);\n}));\n\n(re_frame.core.on_changes.cljs$lang$maxFixedArity \x3d (2));\n\n/** @this {Function} */\n(re_frame.core.on_changes.cljs$lang$applyTo \x3d (function (seq50403){\nvar G__50404 \x3d cljs.core.first(seq50403);\nvar seq50403__$1 \x3d cljs.core.next(seq50403);\nvar G__50405 \x3d cljs.core.first(seq50403__$1);\nvar seq50403__$2 \x3d cljs.core.next(seq50403__$1);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__50404,G__50405,seq50403__$2);\n}));\n\n/**\n * Registers the given `interceptor` as a global interceptor. Global interceptors are\n * included in the processing chain of every event.\n * \n * When you register an event handler, you have the option of supplying an\n * interceptor chain. Any global interceptors you register are effectively\n * prepending to this chain.\n * \n * Global interceptors are run in the order that they are registered.\n */\nre_frame.core.reg_global_interceptor \x3d (function re_frame$core$reg_global_interceptor(interceptor){\nreturn re_frame.settings.reg_global_interceptor(interceptor);\n});\n/**\n * Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\n * \n *   When called with no args, it will unregister all currently registered global interceptors.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   global interceptors, it will unregister the associated interceptor. Will produce a warning to\n *   console if it finds no matching registration.\n */\nre_frame.core.clear_global_interceptor \x3d (function re_frame$core$clear_global_interceptor(var_args){\nvar G__50407 \x3d arguments.length;\nswitch (G__50407) {\ncase 0:\nreturn re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$0 \x3d (function (){\nreturn re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$0();\n}));\n\n(re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$1 \x3d (function (id){\nreturn re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$1(id);\n}));\n\n(re_frame.core.clear_global_interceptor.cljs$lang$maxFixedArity \x3d 1);\n\n/**\n * A utility function for creating interceptors.\n * \n *   Accepts three optional, named arguments:\n * \n *   - `:id` - an id for the interceptor (decorative only)\n *   - `:before` - the interceptor\x27s before function\n *   - `:after`  - the interceptor\x27s after function\n * \n *   Example use:\n * \n *    #!clj\n *    (def my-interceptor\n *      (-\x3einterceptor\n *       :id     :my-interceptor\n *       :before (fn [context]\n *                 ... modifies and returns `context`)\n *       :after  (fn [context]\n *                 ... modifies and returns `context`)))\n * \n *   Notes:\n * \n *  - `:before` functions modify and return their `context` argument. Sometimes they\n *    only side effect, in which case, they\x27ll perform the side effect and return\n *    `context` unchanged.\n *  - `:before` functions often modify the `:coeffects` map within `context` and,\n *    if they do, then they should use the utility functions `get-coeffect` and\n *    `assoc-coeffect`.\n *  - `:after` functions modify and return their `context` argument. Sometimes they\n *    only side effect, in which case, they\x27ll perform the side effect and return\n *    `context` unchanged.\n *  - `:after` functions often modify the `:effects` map within `context` and,\n *    if they do, then they should use the utility functions `get-effect`\n *    and `assoc-effect`\n */\nre_frame.core.__GT_interceptor \x3d (function re_frame$core$__GT_interceptor(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50484 \x3d arguments.length;\nvar i__5770__auto___50485 \x3d (0);\nwhile(true){\nif((i__5770__auto___50485 \x3c len__5769__auto___50484)){\nargs__5775__auto__.push((arguments[i__5770__auto___50485]));\n\nvar G__50486 \x3d (i__5770__auto___50485 + (1));\ni__5770__auto___50485 \x3d G__50486;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((0) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(re_frame.core.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic \x3d (function (p__50413){\nvar map__50414 \x3d p__50413;\nvar map__50414__$1 \x3d cljs.core.__destructure_map(map__50414);\nvar m \x3d map__50414__$1;\nvar id \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50414__$1,new cljs.core.Keyword(null,\x22id\x22,\x22id\x22,-1388402092));\nvar before \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50414__$1,new cljs.core.Keyword(null,\x22before\x22,\x22before\x22,-1633692388));\nvar after \x3d cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__50414__$1,new cljs.core.Keyword(null,\x22after\x22,\x22after\x22,594996914));\nreturn re_frame.utils.apply_kw.cljs$core$IFn$_invoke$arity$variadic(re_frame.interceptor.__GT_interceptor,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([m], 0));\n}));\n\n(re_frame.core.__GT_interceptor.cljs$lang$maxFixedArity \x3d (0));\n\n/** @this {Function} */\n(re_frame.core.__GT_interceptor.cljs$lang$applyTo \x3d (function (seq50409){\nvar self__5755__auto__ \x3d this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq50409));\n}));\n\n/**\n * A utility function, typically used when writing an interceptor\x27s `:before` function.\n * \n * When called with one argument, it returns the `:coeffects` map from within that `context`.\n * \n * When called with two or three arguments, behaves like `clojure.core/get` and\n * returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\n * `nil` if `key` is not present.\n */\nre_frame.core.get_coeffect \x3d (function re_frame$core$get_coeffect(var_args){\nvar G__50416 \x3d arguments.length;\nswitch (G__50416) {\ncase 1:\nreturn re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$1 \x3d (function (context){\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context);\n}));\n\n(re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$2 \x3d (function (context,key){\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,key);\n}));\n\n(re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$3 \x3d (function (context,key,not_found){\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$3(context,key,not_found);\n}));\n\n(re_frame.core.get_coeffect.cljs$lang$maxFixedArity \x3d 3);\n\n/**\n * A utility function, typically used when writing an interceptor\x27s `:before` function.\n * \n * Adds or updates a key/value pair in the `:coeffects` map within `context`. \n */\nre_frame.core.assoc_coeffect \x3d (function re_frame$core$assoc_coeffect(context,key,value){\nreturn re_frame.interceptor.assoc_coeffect(context,key,value);\n});\n/**\n * A utility function, used when writing interceptors, typically within an `:after` function.\n * \n * When called with one argument, returns the `:effects` map from the `context`.\n * \n * When called with two or three arguments, behaves like `clojure.core/get` and\n * returns the value mapped to `key` in the effects map, `not-found` or\n * `nil` if `key` is not present.\n */\nre_frame.core.get_effect \x3d (function re_frame$core$get_effect(var_args){\nvar G__50419 \x3d arguments.length;\nswitch (G__50419) {\ncase 1:\nreturn re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$1 \x3d (function (context){\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(context);\n}));\n\n(re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$2 \x3d (function (context,key){\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2(context,key);\n}));\n\n(re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$3 \x3d (function (context,key,not_found){\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$3(context,key,not_found);\n}));\n\n(re_frame.core.get_effect.cljs$lang$maxFixedArity \x3d 3);\n\n/**\n * A utility function, typically used when writing an interceptor\x27s `:after` function.\n * \n * Adds or updates a key/value pair in the `:effects` map within `context`. \n */\nre_frame.core.assoc_effect \x3d (function re_frame$core$assoc_effect(context,key,value){\nreturn re_frame.interceptor.assoc_effect(context,key,value);\n});\n/**\n * A utility function, used when writing an interceptor\x27s `:before` function.\n * \n *   Adds the given collection of `interceptors` to those already in `context\x27s`\n *   execution `:queue`. It returns the updated `context`.\n * \n *   So, it provides a way for one interceptor to add more interceptors to the\n *   currently executing interceptor chain.\n *   \n */\nre_frame.core.enqueue \x3d (function re_frame$core$enqueue(context,interceptors){\nreturn re_frame.interceptor.enqueue(context,interceptors);\n});\n/**\n * re-frame outputs warnings and errors via the API function `console`\n * which, by default, delegates to `js/console`\x27s default implementation for\n *   `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\n * you can override that behaviour with your own functions.\n * \n *   The argument `new-loggers` should be a map containing a subset of they keys\n *   for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\n *   or `:groupEnd`.\n * \n *   Example Usage:\n * \n *    #!clj\n *    (defn my-logger      ;; my alternative logging function\n *      [\x26 args]\n *      (post-it-somewhere (apply str args)))\n * \n *    ;; now install my alternative loggers\n *    (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\n * \n */\nre_frame.core.set_loggers_BANG_ \x3d (function re_frame$core$set_loggers_BANG_(new_loggers){\nreturn re_frame.loggers.set_loggers_BANG_(new_loggers);\n});\n/**\n * A utility logging function which is used internally within re-frame to produce\n *   warnings and other output. It can also be used by libraries which\n *   extend re-frame, such as effect handlers.\n * \n *   By default, it will output the given `args` to `js/console` at the given log `level`.\n *   However, an application using re-frame can redirect `console` output via `set-loggers!`.\n * \n *   `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\n * \n *   Example usage:\n * \n *    #!clj\n *    (console :error \x22Sure enough it happened:\x22 a-var \x22and\x22 another)\n *    (console :warn \x22Possible breach of containment wall at:\x22 dt)\n *   \n */\nre_frame.core.console \x3d (function re_frame$core$console(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50495 \x3d arguments.length;\nvar i__5770__auto___50496 \x3d (0);\nwhile(true){\nif((i__5770__auto___50496 \x3c len__5769__auto___50495)){\nargs__5775__auto__.push((arguments[i__5770__auto___50496]));\n\nvar G__50498 \x3d (i__5770__auto___50496 + (1));\ni__5770__auto___50496 \x3d G__50498;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((1) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((1)),(0),null)):null);\nreturn re_frame.core.console.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5776__auto__);\n});\n\n(re_frame.core.console.cljs$core$IFn$_invoke$arity$variadic \x3d (function (level,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(re_frame.loggers.console,level,args);\n}));\n\n(re_frame.core.console.cljs$lang$maxFixedArity \x3d (1));\n\n/** @this {Function} */\n(re_frame.core.console.cljs$lang$applyTo \x3d (function (seq50426){\nvar G__50427 \x3d cljs.core.first(seq50426);\nvar seq50426__$1 \x3d cljs.core.next(seq50426);\nvar self__5754__auto__ \x3d this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__50427,seq50426__$1);\n}));\n\n/**\n * This is a utility function, typically used in testing.\n * \n *   It checkpoints the current state of re-frame and returns a function which, when\n *   later called, will restore re-frame to the checkpointed state.\n * \n *   The checkpoint includes `app-db`, all registered handlers and all subscriptions.\n *   \n */\nre_frame.core.make_restore_fn \x3d (function re_frame$core$make_restore_fn(){\nvar handlers \x3d cljs.core.deref(re_frame.registrar.kind__GT_id__GT_handler);\nvar app_db \x3d cljs.core.deref(re_frame.db.app_db);\nvar subs_cache \x3d cljs.core.deref(re_frame.subs.query__GT_reaction);\nreturn (function (){\nvar original_subs_50503 \x3d cljs.core.set(cljs.core.vals(subs_cache));\nvar current_subs_50504 \x3d cljs.core.set(cljs.core.vals(cljs.core.deref(re_frame.subs.query__GT_reaction)));\nvar seq__50435_50505 \x3d cljs.core.seq(clojure.set.difference.cljs$core$IFn$_invoke$arity$2(current_subs_50504,original_subs_50503));\nvar chunk__50436_50506 \x3d null;\nvar count__50437_50507 \x3d (0);\nvar i__50438_50508 \x3d (0);\nwhile(true){\nif((i__50438_50508 \x3c count__50437_50507)){\nvar sub_50509 \x3d chunk__50436_50506.cljs$core$IIndexed$_nth$arity$2(null,i__50438_50508);\nre_frame.interop.dispose_BANG_(sub_50509);\n\n\nvar G__50510 \x3d seq__50435_50505;\nvar G__50511 \x3d chunk__50436_50506;\nvar G__50512 \x3d count__50437_50507;\nvar G__50513 \x3d (i__50438_50508 + (1));\nseq__50435_50505 \x3d G__50510;\nchunk__50436_50506 \x3d G__50511;\ncount__50437_50507 \x3d G__50512;\ni__50438_50508 \x3d G__50513;\ncontinue;\n} else {\nvar temp__5804__auto___50514 \x3d cljs.core.seq(seq__50435_50505);\nif(temp__5804__auto___50514){\nvar seq__50435_50515__$1 \x3d temp__5804__auto___50514;\nif(cljs.core.chunked_seq_QMARK_(seq__50435_50515__$1)){\nvar c__5568__auto___50516 \x3d cljs.core.chunk_first(seq__50435_50515__$1);\nvar G__50517 \x3d cljs.core.chunk_rest(seq__50435_50515__$1);\nvar G__50518 \x3d c__5568__auto___50516;\nvar G__50519 \x3d cljs.core.count(c__5568__auto___50516);\nvar G__50520 \x3d (0);\nseq__50435_50505 \x3d G__50517;\nchunk__50436_50506 \x3d G__50518;\ncount__50437_50507 \x3d G__50519;\ni__50438_50508 \x3d G__50520;\ncontinue;\n} else {\nvar sub_50521 \x3d cljs.core.first(seq__50435_50515__$1);\nre_frame.interop.dispose_BANG_(sub_50521);\n\n\nvar G__50522 \x3d cljs.core.next(seq__50435_50515__$1);\nvar G__50523 \x3d null;\nvar G__50524 \x3d (0);\nvar G__50525 \x3d (0);\nseq__50435_50505 \x3d G__50522;\nchunk__50436_50506 \x3d G__50523;\ncount__50437_50507 \x3d G__50524;\ni__50438_50508 \x3d G__50525;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\ncljs.core.reset_BANG_(re_frame.registrar.kind__GT_id__GT_handler,handlers);\n\ncljs.core.reset_BANG_(re_frame.db.app_db,app_db);\n\nreturn null;\n});\n});\n/**\n * Removes all events currently queued for processing\n */\nre_frame.core.purge_event_queue \x3d (function re_frame$core$purge_event_queue(){\nreturn re_frame.router.event_queue.re_frame$router$IEventQueue$purge$arity$1(null);\n});\n/**\n * Registers the given function `f` to be called after each event is processed.\n * \n * `f` will be called with two arguments:\n * \n *  - `event`: a vector. The event just processed.\n *  - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n * \n * This facility is useful in advanced cases like:\n * \n *   - you are implementing a complex bootstrap pipeline\n *   - you want to create your own handling infrastructure, with perhaps multiple\n *     handlers for the one event, etc.  Hook in here.\n *   - libraries providing \x27isomorphic javascript\x27 rendering on  Nodejs or Nashorn.\n * \n *   `id` is typically a keyword. If it supplied when an `f` is added, it can be\n *   subsequently be used to identify it for removal. See `remove-post-event-callback`.\n *   \n */\nre_frame.core.add_post_event_callback \x3d (function re_frame$core$add_post_event_callback(var_args){\nvar G__50440 \x3d arguments.length;\nswitch (G__50440) {\ncase 1:\nreturn re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\x22Invalid arity: \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join(\x27\x27)));\n\n}\n});\n\n(re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$1 \x3d (function (f){\nreturn re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2(f,f);\n}));\n\n(re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2 \x3d (function (id,f){\nreturn re_frame.router.event_queue.re_frame$router$IEventQueue$add_post_event_callback$arity$3(null,id,f);\n}));\n\n(re_frame.core.add_post_event_callback.cljs$lang$maxFixedArity \x3d 2);\n\n/**\n * Unregisters a post event callback function, identified by `id`.\n * \n *   Such a function must have been previously registered via `add-post-event-callback`\n */\nre_frame.core.remove_post_event_callback \x3d (function re_frame$core$remove_post_event_callback(id){\nreturn re_frame.router.event_queue.re_frame$router$IEventQueue$remove_post_event_callback$arity$2(null,id);\n});\n/**\n * Deprecated. Use `reg-event-db` instead.\n */\nre_frame.core.register_handler \x3d (function re_frame$core$register_handler(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50529 \x3d arguments.length;\nvar i__5770__auto___50530 \x3d (0);\nwhile(true){\nif((i__5770__auto___50530 \x3c len__5769__auto___50529)){\nargs__5775__auto__.push((arguments[i__5770__auto___50530]));\n\nvar G__50531 \x3d (i__5770__auto___50530 + (1));\ni__5770__auto___50530 \x3d G__50531;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((0) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.register_handler.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(re_frame.core.register_handler.cljs$core$IFn$_invoke$arity$variadic \x3d (function (args){\nre_frame.core.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22register-handler\\\x22 has been renamed \\\x22reg-event-db\\\x22 (look for registration of \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(args)),\x22)\x22], 0));\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(re_frame.core.reg_event_db,args);\n}));\n\n(re_frame.core.register_handler.cljs$lang$maxFixedArity \x3d (0));\n\n/** @this {Function} */\n(re_frame.core.register_handler.cljs$lang$applyTo \x3d (function (seq50444){\nvar self__5755__auto__ \x3d this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq50444));\n}));\n\n/**\n * Deprecated. Use `reg-sub-raw` instead.\n */\nre_frame.core.register_sub \x3d (function re_frame$core$register_sub(var_args){\nvar args__5775__auto__ \x3d [];\nvar len__5769__auto___50532 \x3d arguments.length;\nvar i__5770__auto___50533 \x3d (0);\nwhile(true){\nif((i__5770__auto___50533 \x3c len__5769__auto___50532)){\nargs__5775__auto__.push((arguments[i__5770__auto___50533]));\n\nvar G__50534 \x3d (i__5770__auto___50533 + (1));\ni__5770__auto___50533 \x3d G__50534;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ \x3d ((((0) \x3c args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.register_sub.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(re_frame.core.register_sub.cljs$core$IFn$_invoke$arity$variadic \x3d (function (args){\nre_frame.core.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\x22warn\x22,\x22warn\x22,-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\x22re-frame: \\\x22register-sub\\\x22 is used to register the event \x22,cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(args)),\x22 but it is a deprecated part of the API. Please use \\\x22reg-sub-raw\\\x22 instead.\x22], 0));\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(re_frame.core.reg_sub_raw,args);\n}));\n\n(re_frame.core.register_sub.cljs$lang$maxFixedArity \x3d (0));\n\n/** @this {Function} */\n(re_frame.core.register_sub.cljs$lang$applyTo \x3d (function (seq50446){\nvar self__5755__auto__ \x3d this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq50446));\n}));\n\n");
SHADOW_ENV.evalLoad("sci.configs.re_frame.re_frame.js", true , "goog.provide(\x27sci.configs.re_frame.re_frame\x27);\nsci.configs.re_frame.re_frame.rfns \x3d sci.core.create_ns.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\x22re-frame.core\x22,\x22re-frame.core\x22,-1549073474,null),null);\nsci.configs.re_frame.re_frame.rfdbns \x3d sci.core.create_ns.cljs$core$IFn$_invoke$arity$2(new cljs.core.Symbol(null,\x22re-frame.db\x22,\x22re-frame.db\x22,983930750,null),null);\nsci.configs.re_frame.re_frame.re_frame_namespace \x3d sci.core._copy_ns(cljs.core.PersistentHashMap.fromArrays([cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-sub-raw\x22,\x22reg-sub-raw\x22,784637666,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null),new cljs.core.Symbol(null,\x22handler-fn\x22,\x22handler-fn\x22,841143797,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22This is a low level, advanced function.  You should probably be\\n  using `reg-sub` instead.\\n\\n  Some explanation is available in the docs at\\n  \x3ca href\x3d\\\x22http://day8.github.io/re-frame/flow-mechanics/\\\x22 target\x3d\\\x22_blank\\\x22\x3ehttp://day8.github.io/re-frame/flow-mechanics/\x3c/a\x3e\x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Subscriptions\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22dispatch-sync\x22,\x22dispatch-sync\x22,-990037526,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22event\x22,\x22event\x22,1941966969,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Synchronously (immediately) process `event`. It does **not** queue\\n  the event for handling later as `dispatch` does.\\n\\n  `event` is a vector and the first element is typically a keyword\\n  which identifies the kind of event.\\n\\n  It is an error to use `dispatch-sync` within an event handler because\\n  you can\x27t immediately process an new event when one is already\\n  part way through being processed.\\n\\n  Generally, avoid using this function, and instead, use `dispatch`.\\n  Only use it in the narrow set of cases where any delay in\\n  processing is a problem:\\n\\n    1. the `:on-change` handler of a text field where we are expecting fast typing\\n    2. when initialising your app - see \x27main\x27 in examples/todomvc/src/core.cljs\\n    3. in a unit test where immediate, synchronous processing is useful\\n\\n  Usage:\\n\\n      #!clj\\n      (dispatch-sync [:sing :falsetto \\\x22piano accordion\\\x22])\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Dispatching Events\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-sub\x22,\x22reg-sub\x22,852548167,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Subscriptions\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(1),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(1),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A call to `reg-sub` associates a `query-id` WITH two functions.\\n\\n  The two functions provide \x27a mechanism\x27 for creating a node\\n  in the Signal Graph. When a node of type `query-id` is needed,\\n  the two functions can be used to create it.\\n\\n  The three arguments are:\\n\\n    - `query-id` - typically a namespaced keyword (later used in subscribe)\\n    - optionally, an `input signals` function which returns the input data\\n      flows required by this kind of node.\\n    - a `computation function` which computes the value (output) of the\\n      node (from the input data flows)\\n\\n  Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\\n  will trigger the need for a new `:sub-id` Signal Graph node (matching the\\n  query `[:sub-id 3 :blue]`). And, to create that node the two functions\\n  associated with `:sub-id` will be looked up and used.\\n\\n  Just to be clear: calling `reg-sub` does not immediately create a node.\\n  It only registers \x27a mechanism\x27 (the two functions) by which nodes\\n  can be created later, when a node is bought into existence by the\\n  use of `subscribe` in a `View Function`.\\n\\n  `reg-sub` arguments are:\\n\\n    - a `query-id` (typically a namespaced keyword)\\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\\n    - a function which computes the value of this kind of node (can be supplied in one of three ways)\\n\\n  The `computation function` is always the last argument supplied and has three ways to be called.\\n  Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\\n\\n  1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\\n     standard way to provide a `computation-function`\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            (fn [input-values query-vector]\\n              (:foo input-values)))\\n\\n  2. A single sugary tuple of `:-\x3e` and a 1-arity `computation-function`:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :-\x3e computation-fn)\\n\\n      This sugary variation allows you to pass a function that will expect only one parameter,\\n      namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\\n      expects two parameters which can cause unfortunate results when attempting to use\\n      clojure standard library functions, or other functions, in a functional manner.\\n\\n      For example, a significant number of subscriptions exist only to get a value\\n      from the `input-values`. As shown below, this subscription will simply retrieve\\n      the value associated with the `:foo` key in our db:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            (fn [db _]    ;; :\x3c---- trivial boilerplate we might want to skip over\\n              (:foo db)))\\n\\n      This is slightly more boilerplate than we might like to do,\\n      as we can use a keyword directly as a function, and we might like to do this:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :foo)  ;; :\x3c---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\\n\\n      By using `:-\x3e` our function would not contain the `query-vector`, and any\\n      missing keys would be represented as such:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :-\x3e :foo)\\n\\n      This form allows us to ignore the `query-vector` if our `computation-function`\\n      has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\\n      and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\\n\\n  3. A single sugary tuple of `:\x3d\x3e` and a multi-arity `computation-function`\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :\x3d\x3e computation-fn)\\n\\n      The `query-vector` can be broken into two components `[query-id \x26 optional-values]`, and\\n      some subscriptions require the `optional-values` for extra work within the subscription.\\n      To use them in variation #1, we need to destructure our `computation-function` parameters\\n      in order to use them.\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            (fn [db [_ foo]]\\n              [db foo]))\\n\\n      Again we are writing boilerplate just to reach our values, and we might prefer to\\n      have direction access through a parameter vector like `[input-values optional-values]`\\n      instead, so we might be able to use a multi-arity function directly as our `computation-function`.\\n      A rewrite of the above sub using this sugary syntax would look like this:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :\x3d\x3e vector)  ;; :\x3c---- Could also be `(fn [db foo] [db foo])`\\n\\n  The `computation function` is expected to take two arguments:\\n\\n    - `input-values` - the values which flow into this node (how is it wired into the graph?)\\n    - `query-vector` - the vector given to `subscribe`\\n\\n  and it returns a computed value (which then becomes the output of the node)\\n\\n  When `computation function` is called, the 2nd `query-vector` argument will be that\\n  vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\\n  then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\\n\\n  The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\\n  can vary in 3 ways, but whatever is there defines the `input signals` part\\n  of `the mechanism`, specifying what input values \\\x22flow into\\\x22 the\\n  `computation function` (as the 1st argument) when it is called.\\n\\n  So, `reg-sub` can be called in one of three ways, because there are three ways\\n  to define the input signals part. But note, the 2nd method, in which a\\n  `signals function` is explicitly supplied, is the most canonical and\\n  instructive. The other two are really just sugary variations.\\n\\n  **First variation** - no input signal function given:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\\n\\n     In the absence of an explicit `signals function`, the node\x27s input signal defaults to `app-db`\\n     and, as a result, the value within `app-db` (a map) is\\n     given as the 1st argument when `a-computation-fn` is called.\\n\\n\\n  **Second variation** - a signal function is explicitly supplied:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        signal-fn     ;; \x3c-- here\\n        computation-fn)\\n\\n  This is the most canonical and instructive of the three variations.\\n\\n  When a node is created from the template, the `signal function` will be called and it\\n  is expected to return the input signal(s) as either a singleton, if there is only\\n  one, or a sequence if there are many, or a map with the signals as the values.\\n\\n  The current values of the returned signals will be supplied as the 1st argument to\\n  the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\\n  this value will be either a singleton, sequence or map of them (paralleling\\n  the structure returned by the `signal function`).\\n\\n  This example `signal function` returns a 2-vector of input signals.\\n\\n      #!clj\\n      (fn [query-vec dynamic-vec]\\n         [(subscribe [:a-sub])\\n          (subscribe [:b-sub])])\\n\\n  The associated computation function must be written\\n  to expect a 2-vector of values for its first argument:\\n\\n      #!clj\\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\\n        ....)\\n\\n  If, on the other hand, the signal function was simpler and returned a singleton, like this:\\n\\n      #!clj\\n      (fn [query-vec dynamic-vec]\\n        (subscribe [:a-sub]))      ;; \x3c-- returning a singleton\\n\\n  then the associated computation function must be written to expect a single value\\n  as the 1st argument:\\n\\n      #!clj\\n      (fn [a query-vec]       ;; 1st argument is a single value\\n         ...)\\n\\n  Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\\n\\n  is the equivalent of using this\\n  2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        (fn [_ _]  re-frame/app-db)   ;; \x3c--- explicit signal-fn\\n        a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\\n\\n  **Third variation** - syntax Sugar\\n\\n      #!clj\\n      (reg-sub\\n        :a-b-sub\\n        :\x3c- [:a-sub]\\n        :\x3c- [:b-sub]\\n        (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\\n          {:a a :b b}))\\n\\n  This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\\n  `signals-fn` you provide one or more pairs of `:\x3c-` and a subscription vector.\\n\\n  If you supply only one pair a singleton will be supplied to the computation function,\\n  as if you had supplied a `signal-fn` returning only a single value:\\n\\n      #!clj\\n      (reg-sub\\n        :a-sub\\n        :\x3c- [:a-sub]\\n        (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\\n          ...))\\n\\n  Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\\n  and the direction of arrows shows the flow of data and functions. The example from\\n  directly above is reproduced here:\\n\\n      #!clj\\n      (reg-sub\\n        :a-b-sub\\n        :\x3c- [:a-sub]\\n        :\x3c- [:b-sub]\\n        :-\x3e (partial zipmap [:a :b]))\\n\\n  For further understanding, read the tutorials, and look at the detailed comments in\\n  /examples/todomvc/src/subs.cljs.\\n\\n  See also: `subscribe`\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22dispatch\x22,\x22dispatch\x22,-1335098760,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22event\x22,\x22event\x22,1941966969,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Queue `event` for processing (handling).\\n\\n  `event` is a vector and the first element is typically a keyword\\n  which identifies the kind of event.\\n\\n  The event will be added to a FIFO processing queue, so event\\n  handling does not happen immediately. It will happen \x27very soon\x27\\n  but not now. And if the queue already contains events, they\\n  will be processed first.\\n\\n  Usage:\\n\\n      #!clj\\n      (dispatch [:order \\\x22pizza\\\x22 {:supreme 2 :meatlovers 1 :veg 1}])\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Dispatching Events\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22unwrap\x22,\x22unwrap\x22,241356065,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-event-fx\x22,\x22reg-event-fx\x22,350713021,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Event Handlers\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),3,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),3,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given event `handler` (function) for the given `id`. Optionally, provide\\n  an `interceptors` chain:\\n\\n    - `id` is typically a namespaced keyword  (but can be anything)\\n    - `handler` is a function: (coeffects-map event-vector) -\x3e effects-map\\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\\n\\n\\n  Example Usage:\\n\\n      #!clj\\n      (reg-event-fx\\n        :event-id\\n        (fn [cofx event]\\n          {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\\n\\n\\n  Or perhaps:\\n\\n      #!clj\\n      (reg-event-fx\\n        :namespaced/id           ;; \x3c-- namespaced keywords are often used\\n        [one two three]          ;; \x3c-- a seq of interceptors\\n        (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\\n          {:db (assoc db :some-key arg1)          ;; return a map of effects\\n           :fx [[:dispatch [:some-event arg2]]]}))\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22enqueue\x22,\x22enqueue\x22,1377000435,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, used when writing an interceptor\x27s `:before` function.\\n\\n  Adds the given collection of `interceptors` to those already in `context\x27s`\\n  execution `:queue`. It returns the updated `context`.\\n\\n  So, it provides a way for one interceptor to add more interceptors to the\\n  currently executing interceptor chain.\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Writing Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22get-coeffect\x22,\x22get-coeffect\x22,1018510098,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Writing Interceptors\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),3,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),3,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, typically used when writing an interceptor\x27s `:before` function.\\n\\n   When called with one argument, it returns the `:coeffects` map from within that `context`.\\n\\n   When called with two or three arguments, behaves like `clojure.core/get` and\\n   returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\\n   `nil` if `key` is not present.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22clear-event\x22,\x22clear-event\x22,-1884567988,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Event Handlers\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),1,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),1,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\\n\\n  When called with no args, it will unregister all currently registered event handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  event handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22subscribe\x22,\x22subscribe\x22,2056785283,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Subscriptions\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),2,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),2,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null),new cljs.core.Symbol(null,\x22dynv\x22,\x22dynv\x22,-405952138,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null),new cljs.core.Symbol(null,\x22dynv\x22,\x22dynv\x22,-405952138,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null),new cljs.core.Symbol(null,\x22dynv\x22,\x22dynv\x22,-405952138,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Given a `query` vector, returns a Reagent `reaction` which will, over\\n  time, reactively deliver a stream of values. So, in FRP-ish terms,\\n  it returns a `Signal`.\\n\\n  To obtain the current value from the Signal, it must be dereferenced:\\n\\n      #!clj\\n      (let [signal (subscribe [:items])\\n            value  (deref signal)]     ;; could be written as @signal\\n        ...)\\n\\n   which is typically written tersely as simple:\\n\\n      #!clj\\n      (let [items  @(subscribe [:items])]\\n        ...)\\n\\n\\n  `query` is a vector of at least one element. The first element is the\\n  `query-id`, typically a namespaced keyword. The rest of the vector\x27s\\n  elements are optional, additional values which parameterise the query\\n  performed.\\n\\n  `dynv` is an optional 3rd argument, which is a vector of further input\\n  signals (atoms, reactions, etc), NOT values. This argument exists for\\n  historical reasons and is borderline deprecated these days.\\n\\n  **Example Usage**:\\n\\n      #!clj\\n      (subscribe [:items])\\n      (subscribe [:items \\\x22blue\\\x22 :small])\\n      (subscribe [:items {:colour \\\x22blue\\\x22  :size :small}])\\n\\n  Note: for any given call to `subscribe` there must have been a previous call\\n  to `reg-sub`, registering the query handler (functions) associated with\\n  `query-id`.\\n\\n  **Hint**\\n\\n  When used in a view function BE SURE to `deref` the returned value.\\n  In fact, to avoid any mistakes, some prefer to define:\\n\\n      #!clj\\n      (def \x3csub  (comp deref re-frame.core/subscribe))\\n\\n  And then, within their views, they call  `(\x3csub [:items :small])` rather\\n  than using `subscribe` directly.\\n\\n  **De-duplication**\\n\\n  Two, or more, concurrent subscriptions for the same query will\\n  source reactive updates from the one executing handler.\\n\\n  See also: `reg-sub`\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22clear-fx\x22,\x22clear-fx\x22,1936947081,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Effect Handlers\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),1,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),1,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\\n\\n  When called with no args, it will unregister all currently registered effect handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  effect handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-event-ctx\x22,\x22reg-event-ctx\x22,1495496276,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Event Handlers\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),3,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),3,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given event `handler` (function) for the given `id`. Optionally, provide\\n  an `interceptors` chain:\\n\\n    - `id` is typically a namespaced keyword  (but can be anything)\\n    - `handler` is a function: context-map -\x3e context-map\\n\\n  You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\\n\\n  Example Usage:\\n\\n      #!clj\\n      (reg-event-ctx\\n        :event-id\\n        (fn [{:keys [coeffects] :as context}]\\n          (let [initial  {:db     (:db coeffects)\\n                          :event  (:event coeffects)\\n                          :fx     []}\\n                result   (-\x3e initial\\n                             function1\\n                             function2\\n                             function3)\\n                effects  (select-keys result [:db :fx])]\\n             (assoc context :effects effects))))\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22add-post-event-callback\x22,\x22add-post-event-callback\x22,182608154,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Miscellaneous\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),2,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),2,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Registers the given function `f` to be called after each event is processed.\\n\\n   `f` will be called with two arguments:\\n\\n    - `event`: a vector. The event just processed.\\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\\n\\n   This facility is useful in advanced cases like:\\n\\n     - you are implementing a complex bootstrap pipeline\\n     - you want to create your own handling infrastructure, with perhaps multiple\\n       handlers for the one event, etc.  Hook in here.\\n     - libraries providing \x27isomorphic javascript\x27 rendering on  Nodejs or Nashorn.\\n\\n  `id` is typically a keyword. If it supplied when an `f` is added, it can be\\n  subsequently be used to identify it for removal. See `remove-post-event-callback`.\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-fx\x22,\x22reg-fx\x22,-87443115,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given effect `handler` for the given `id`:\\n\\n    - `id` is keyword, often namespaced.\\n    - `handler` is a side-effecting function which takes a single argument and whose return\\n      value is ignored.\\n\\n  To use, first, associate `:effect2` with a handler:\\n\\n      #!clj\\n      (reg-fx\\n         :effect2\\n         (fn [value]\\n            ... do something side-effect-y))\\n\\n  Then, later, if an event handler were to return this effects map:\\n\\n      #!clj\\n      {:effect2  [1 2]}\\n\\n  then the `handler` `fn` we registered previously, using `reg-fx`, will be\\n  called with an argument of `[1 2]`.\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Effect Handlers\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22enrich\x22,\x22enrich\x22,-468390398,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which will run the given function `f` in the `:after`\\n  position.\\n\\n  `f` is called with two arguments: `db` and `event`, and is expected to\\n  return a modified `db`.\\n\\n  Unlike the `after` interceptor which is only about side effects, `enrich`\\n  expects `f` to process and alter the given `db` coeffect in some useful way,\\n  contributing to the derived data, flowing vibe.\\n\\n  If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\\n\\n  #### Example Use:\\n\\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\\n  the same text, then highlight their background, and report them via a warning\\n  at the bottom of the panel.\\n\\n  Almost any user action (edit text, add new todo, remove a todo) requires a\\n  complete reassessment of duplication errors and warnings. E.g. that edit\\n  just made might have introduced a new duplicate, or removed one. Same with\\n  any todo removal. So we need to re-calculate warnings after any CRUD events\\n  associated with the todos list.\\n\\n  Unless we are careful, we might end up coding subtly different checks\\n  for each kind of CRUD operation.  The duplicates check made after\\n  \x27delete todo\x27 event might be subtly different to that done after an\\n  editing operation. Nice and efficient, but fiddly. A bug generator\\n  approach.\\n\\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\\n  every time there is ANY change. It will inspect all the todos, and\\n  reset ALL FLAGS every time (overwriting what was there previously)\\n  and fully recalculate the list of duplicates (displayed at the bottom?).\\n\\n  \x3ca href\x3d\\\x22https://twitter.com/nathanmarz/status/879722740776939520\\\x22 target\x3d\\\x22_blank\\\x22\x3ehttps://twitter.com/nathanmarz/status/879722740776939520\x3c/a\x3e\\n\\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\\n  we keep the handlers simple and yet we ensure this important step\\n  (of getting warnings right) is not missed on any change.\\n\\n  We can test `f` easily - it is a pure function - independently of\\n  any CRUD operation.\\n\\n  This brings huge simplicity at the expense of some re-computation\\n  each time. This may be a very satisfactory trade-off in many cases.\\n\\n  #### Returning nil\\n\\n  In some cases, it\x27s useful to apply a change to specific situations that can\\n  be determined at runtime instead of when defining the handler with an\\n  `:enrich` interceptor. Instead of forcing you to return the `db` from every\\n  non-applicable branch, you can return `nil` to use the given `db` value:\\n\\n      #!clj\\n      (def set-last-update\\n        (core/enrich\\n          (fn [{db :db} [_ {user :user}]]\\n            (when (active-user? user)  ;; \x3c- Only perform an update if user is active\\n              ...))))\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-global-interceptor\x22,\x22reg-global-interceptor\x22,2060591173,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22interceptor\x22,\x22interceptor\x22,-1526696693,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Registers the given `interceptor` as a global interceptor. Global interceptors are\\n   included in the processing chain of every event.\\n\\n   When you register an event handler, you have the option of supplying an\\n   interceptor chain. Any global interceptors you register are effectively\\n   prepending to this chain.\\n\\n   Global interceptors are run in the order that they are registered.\x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Global Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22console\x22,\x22console\x22,-1426363712,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Logging\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(1),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(1),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,\x22level\x22,\x22level\x22,-1363938217,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22level\x22,\x22level\x22,-1363938217,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22level\x22,\x22level\x22,-1363938217,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility logging function which is used internally within re-frame to produce\\n  warnings and other output. It can also be used by libraries which\\n  extend re-frame, such as effect handlers.\\n\\n  By default, it will output the given `args` to `js/console` at the given log `level`.\\n  However, an application using re-frame can redirect `console` output via `set-loggers!`.\\n\\n  `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\\n\\n  Example usage:\\n\\n      #!clj\\n      (console :error \\\x22Sure enough it happened:\\\x22 a-var \\\x22and\\\x22 another)\\n      (console :warn \\\x22Possible breach of containment wall at:\\\x22 dt)\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22clear-cofx\x22,\x22clear-cofx\x22,1267145204,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Coeffects\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),1,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),1,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\\n\\n  When called with no args, it will unregister all currently registered coeffect handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  coeffect handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-cofx\x22,\x22reg-cofx\x22,91685178,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given coeffect `handler` for the given `id`, for later use\\n  within `inject-cofx`:\\n\\n    - `id` is keyword, often namespaced.\\n    - `handler` is a function which takes either one or two arguments, the first of which is\\n       always `coeffects` and which returns an updated `coeffects`.\\n\\n  See also: `inject-cofx`\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Coeffects\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22after\x22,\x22after\x22,-2059438855,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which runs the given function `f` in the `:after`\\n  position, presumably for side effects.\\n\\n  `f` is called with two arguments: the `:effects` value for `:db`\\n  (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\\n  Its return value is ignored, so `f` can only side-effect.\\n\\n  An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\\n\\n     - `f` runs schema validation (reporting any errors found).\\n     - `f` writes to localstorage.\x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22register-handler\x22,\x22register-handler\x22,-2025780993,null),new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Deprecated\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(0),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(0),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22deprecated\x22,\x22deprecated\x22,1498275348),\x220.8.0\x22,new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Deprecated. Use `reg-event-db` instead.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22set-loggers!\x22,\x22set-loggers!\x22,-1947820787,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22new-loggers\x22,\x22new-loggers\x22,-1268568509,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22re-frame outputs warnings and errors via the API function `console`\\n   which, by default, delegates to `js/console`\x27s default implementation for\\n  `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\\n   you can override that behaviour with your own functions.\\n\\n  The argument `new-loggers` should be a map containing a subset of they keys\\n  for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\\n  or `:groupEnd`.\\n\\n  Example Usage:\\n\\n      #!clj\\n      (defn my-logger      ;; my alternative logging function\\n        [\x26 args]\\n        (post-it-somewhere (apply str args)))\\n\\n      ;; now install my alternative loggers\\n      (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\\n   \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Logging\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22assoc-effect\x22,\x22assoc-effect\x22,300107315,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, typically used when writing an interceptor\x27s `:after` function.\\n\\n   Adds or updates a key/value pair in the `:effects` map within `context`. \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Writing Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22on-changes\x22,\x22on-changes\x22,-1308523167,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(2),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(2),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null),new cljs.core.Symbol(null,\x22out-path\x22,\x22out-path\x22,-923103991,null),new cljs.core.Symbol(null,\x22in-paths\x22,\x22in-paths\x22,-1809668720,null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null),new cljs.core.Symbol(null,\x22out-path\x22,\x22out-path\x22,-923103991,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22in-paths\x22,\x22in-paths\x22,-1809668720,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null),new cljs.core.Symbol(null,\x22out-path\x22,\x22out-path\x22,-923103991,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22in-paths\x22,\x22in-paths\x22,-1809668720,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which will observe N paths within `db`, and if any of them\\n  test not `identical?` to their previous value  (as a result of a event handler\\n  being run), then it will run `f` to compute a new value, which is then assoc-ed\\n  into the given `out-path` within `db`.\\n\\n  Example Usage:\\n\\n      #!clj\\n      (defn my-f\\n        [a-val b-val]\\n        ... some computation on a and b in here)\\n\\n      ;; use it\\n      (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\\n\\n      (reg-event-db\\n        :event-id\\n        [... my-interceptor ...]  ;; \x3c-- ultimately used here\\n        (fn [db v]\\n           ...))\\n\\n\\n  If you put this interceptor on handlers which might change paths `:a` or `:b`,\\n  it will:\\n\\n    - call `f` each time the value at path `[:a]` or `[:b]` changes\\n    - call `f` with the values extracted from `[:a]` `[:b]`\\n    - assoc the return value from `f` into the path  `[:c]`\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22clear-subscription-cache!\x22,\x22clear-subscription-cache!\x22,1196020095,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Removes all subscriptions from the cache.\\n\\n  This function can be used at development time or test time. Useful when hot reloading\\n  namespaces containing subscription handlers. Also call it after a React/render exception,\\n  because React components won\x27t have been cleaned up properly. And this, in turn, means\\n  the subscriptions within those components won\x27t have been cleaned up correctly. So this\\n  forces the issue.\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Subscriptions\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22get-effect\x22,\x22get-effect\x22,116827434,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Writing Interceptors\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),3,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),3,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, used when writing interceptors, typically within an `:after` function.\\n\\n   When called with one argument, returns the `:effects` map from the `context`.\\n\\n   When called with two or three arguments, behaves like `clojure.core/get` and\\n   returns the value mapped to `key` in the effects map, `not-found` or\\n   `nil` if `key` is not present.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22register-sub\x22,\x22register-sub\x22,2032582885,null),new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Deprecated\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(0),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(0),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22deprecated\x22,\x22deprecated\x22,1498275348),\x220.8.0\x22,new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Deprecated. Use `reg-sub-raw` instead.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22path\x22,\x22path\x22,1452340359,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(0),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(0),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\\n  the event handler is given a specific part of `app-db` to change, not all of `app-db`.\\n\\n  The interceptor has both a `:before` and `:after` functions. The `:before` replaces\\n  the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\\n  and it grafts the handler\x27s return value back into db, at the right path.\\n\\n  Examples:\\n\\n      #!clj\\n      (path :some :path)\\n      (path [:some :path])\\n      (path [:some :path] :to :here)\\n      (path [:some :path] [:to] :here)\\n\\n  Example Use:\\n\\n      #!clj\\n      (reg-event-db\\n        :event-id\\n        (path [:a :b])  ;; \x3c-- used here, in interceptor chain\\n        (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\\n          ... new-b))   ;; returns a new value for that path (not the entire db)\\n\\n  Notes:\\n\\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\\n    2. if `:effects` contains no `:db` effect, can\x27t graft a value back in.\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22clear-global-interceptor\x22,\x22clear-global-interceptor\x22,-1607850608,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Global Interceptors\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),1,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),1,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\\n\\n  When called with no args, it will unregister all currently registered global interceptors.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  global interceptors, it will unregister the associated interceptor. Will produce a warning to\\n  console if it finds no matching registration.\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22clear-sub\x22,\x22clear-sub\x22,-1368681160,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Subscriptions\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),1,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),1,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\\n\\n  When called with no args, it will unregister all currently registered subscription handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  subscription handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\\n\\n  NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22trim-v\x22,\x22trim-v\x22,365592887,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22-\x3einterceptor\x22,\x22-\x3einterceptor\x22,-390826100,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Writing Interceptors\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),true,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),(0),new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),(0),new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22as\x22,\x22as\x22,1148689641),new cljs.core.Symbol(null,\x22m\x22,\x22m\x22,-1021758608,null),new cljs.core.Keyword(null,\x22keys\x22,\x22keys\x22,1068423698),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22before\x22,\x22before\x22,6839139,null),new cljs.core.Symbol(null,\x22after\x22,\x22after\x22,-2059438855,null)], null)], null))], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22as\x22,\x22as\x22,1148689641),new cljs.core.Symbol(null,\x22m\x22,\x22m\x22,-1021758608,null),new cljs.core.Keyword(null,\x22keys\x22,\x22keys\x22,1068423698),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22before\x22,\x22before\x22,6839139,null),new cljs.core.Symbol(null,\x22after\x22,\x22after\x22,-2059438855,null)], null)], null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22as\x22,\x22as\x22,1148689641),new cljs.core.Symbol(null,\x22m\x22,\x22m\x22,-1021758608,null),new cljs.core.Keyword(null,\x22keys\x22,\x22keys\x22,1068423698),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22before\x22,\x22before\x22,6839139,null),new cljs.core.Symbol(null,\x22after\x22,\x22after\x22,-2059438855,null)], null)], null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function for creating interceptors.\\n\\n  Accepts three optional, named arguments:\\n\\n     - `:id` - an id for the interceptor (decorative only)\\n     - `:before` - the interceptor\x27s before function\\n     - `:after`  - the interceptor\x27s after function\\n\\n  Example use:\\n\\n      #!clj\\n      (def my-interceptor\\n        (-\x3einterceptor\\n         :id     :my-interceptor\\n         :before (fn [context]\\n                   ... modifies and returns `context`)\\n         :after  (fn [context]\\n                   ... modifies and returns `context`)))\\n\\n  Notes:\\n\\n    - `:before` functions modify and return their `context` argument. Sometimes they\\n      only side effect, in which case, they\x27ll perform the side effect and return\\n      `context` unchanged.\\n    - `:before` functions often modify the `:coeffects` map within `context` and,\\n      if they do, then they should use the utility functions `get-coeffect` and\\n      `assoc-coeffect`.\\n    - `:after` functions modify and return their `context` argument. Sometimes they\\n      only side effect, in which case, they\x27ll perform the side effect and return\\n      `context` unchanged.\\n    - `:after` functions often modify the `:effects` map within `context` and,\\n      if they do, then they should use the utility functions `get-effect`\\n      and `assoc-effect`\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22make-restore-fn\x22,\x22make-restore-fn\x22,-439197753,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22This is a utility function, typically used in testing.\\n\\n  It checkpoints the current state of re-frame and returns a function which, when\\n  later called, will restore re-frame to the checkpointed state.\\n\\n  The checkpoint includes `app-db`, all registered handlers and all subscriptions.\\n  \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Miscellaneous\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22purge-event-queue\x22,\x22purge-event-queue\x22,-1780102203,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(cljs.core.PersistentVector.EMPTY)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Removes all events currently queued for processing\x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Miscellaneous\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22debug\x22,\x22debug\x22,32358931,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22assoc-coeffect\x22,\x22assoc-coeffect\x22,891917445,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, typically used when writing an interceptor\x27s `:before` function.\\n\\n   Adds or updates a key/value pair in the `:coeffects` map within `context`. \x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Writing Interceptors\x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22reg-event-db\x22,\x22reg-event-db\x22,1898199338,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Event Handlers\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),3,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),3,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given event `handler` (function) for the given `id`. Optionally, provide\\n  an `interceptors` chain:\\n\\n    - `id` is typically a namespaced keyword  (but can be anything)\\n    - `handler` is a function: (db event) -\x3e db\\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\\n\\n  Example Usage:\\n\\n      #!clj\\n      (reg-event-db\\n        :token\\n        (fn [db event]\\n          (assoc db :some-key (get event 2)))  ;; return updated db\\n\\n  Or perhaps:\\n\\n      #!clj\\n      (reg-event-db\\n        :namespaced/id           ;; \x3c-- namespaced keywords are often used\\n        [one two three]          ;; \x3c-- a seq of interceptors\\n        (fn [db [_ arg1 arg2]]   ;; \x3c-- event vector is destructured\\n          (-\x3e db\\n            (dissoc arg1)\\n            (update :key + arg2))))   ;; return updated db\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22inject-cofx\x22,\x22inject-cofx\x22,-1494968627,null),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Coeffects\x22,new cljs.core.Keyword(null,\x22top-fn\x22,\x22top-fn\x22,-2056129173),new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\x22variadic?\x22,\x22variadic?\x22,584179762),false,new cljs.core.Keyword(null,\x22fixed-arity\x22,\x22fixed-arity\x22,1586445869),2,new cljs.core.Keyword(null,\x22max-fixed-arity\x22,\x22max-fixed-arity\x22,-690205543),2,new cljs.core.Keyword(null,\x22method-params\x22,\x22method-params\x22,-980792179),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null)),new cljs.core.Keyword(null,\x22arglists-meta\x22,\x22arglists-meta\x22,1944829838),cljs.core.list(null,null)], null),new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Given an `id`, and an optional, arbitrary `value`, returns an interceptor\\n  whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\\n  \x27coeffect handler\x27 identified by the `id`.\\n\\n  The previous association of a `coeffect handler` with an `id` will have\\n  happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\\n\\n  Within the created interceptor, this \x27looked up\x27 `coeffect handler` will\\n  be called (within the `:before`) with two arguments:\\n\\n  - the current value of `:coeffects`\\n  - optionally, the originally supplied arbitrary `value`\\n\\n  This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\\n\\n  **Example of `inject-cofx` and `reg-cofx` working together**\\n\\n\\n  First - Early in app startup, you register a `coeffect handler` for `:datetime`:\\n\\n      #!clj\\n      (re-frame.core/reg-cofx\\n        :datetime                        ;; usage  (inject-cofx :datetime)\\n        (fn coeffect-handler\\n          [coeffect]\\n          (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\\n\\n  Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\\n\\n      #!clj\\n      (re-frame.core/reg-event-fx            ;; when registering an event handler\\n        :event-id\\n        [ ... (inject-cofx :datetime) ... ]  ;; \x3c-- create an injecting interceptor\\n        (fn event-handler\\n          [coeffect event]\\n            ;;... in here can access (:now coeffect) to obtain current datetime ...\\n          )))\\n\\n  **Background**\\n\\n  `coeffects` are the input resources required by an event handler\\n  to perform its job. The two most obvious ones are `db` and `event`.\\n  But sometimes an event handler might need other resources.\\n\\n  Perhaps an event handler needs a random number or a GUID or the current\\n  datetime. Perhaps it needs access to a DataScript database connection.\\n\\n  If an event handler directly accesses these resources, it stops being\\n  pure and, consequently, it becomes harder to test, etc. So we don\x27t\\n  want that.\\n\\n  Instead, the interceptor created by this function is a way to \x27inject\x27\\n  \x27necessary resources\x27 into the `:coeffects` (map) subsequently given\\n  to the event handler at call time.\\n\\n  See also `reg-cofx`\\n  \x22], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\x22remove-post-event-callback\x22,\x22remove-post-event-callback\x22,-909482234,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.Symbol(null,\x22quote\x22,\x22quote\x22,1377916282,null),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null))),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters a post event callback function, identified by `id`.\\n\\n  Such a function must have been previously registered via `add-post-event-callback`\x22,new cljs.core.Keyword(\x22api-docs\x22,\x22heading\x22,\x22api-docs/heading\x22,2007966345),\x22Miscellaneous\x22], null))],[new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-sub-raw\x22,\x22re-frame.core/reg-sub-raw\x22,-1992472244,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_sub_raw,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null),new cljs.core.Symbol(null,\x22handler-fn\x22,\x22handler-fn\x22,841143797,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22This is a low level, advanced function.  You should probably be\\n  using `reg-sub` instead.\\n\\n  Some explanation is available in the docs at\\n  \x3ca href\x3d\\\x22http://day8.github.io/re-frame/flow-mechanics/\\\x22 target\x3d\\\x22_blank\\\x22\x3ehttp://day8.github.io/re-frame/flow-mechanics/\x3c/a\x3e\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22dispatch-sync\x22,\x22re-frame.core/dispatch-sync\x22,-1113172660,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.dispatch_sync,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22event\x22,\x22event\x22,1941966969,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Synchronously (immediately) process `event`. It does **not** queue\\n  the event for handling later as `dispatch` does.\\n\\n  `event` is a vector and the first element is typically a keyword\\n  which identifies the kind of event.\\n\\n  It is an error to use `dispatch-sync` within an event handler because\\n  you can\x27t immediately process an new event when one is already\\n  part way through being processed.\\n\\n  Generally, avoid using this function, and instead, use `dispatch`.\\n  Only use it in the narrow set of cases where any delay in\\n  processing is a problem:\\n\\n    1. the `:on-change` handler of a text field where we are expecting fast typing\\n    2. when initialising your app - see \x27main\x27 in examples/todomvc/src/core.cljs\\n    3. in a unit test where immediate, synchronous processing is useful\\n\\n  Usage:\\n\\n      #!clj\\n      (dispatch-sync [:sing :falsetto \\\x22piano accordion\\\x22])\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-sub\x22,\x22re-frame.core/reg-sub\x22,-1693960551,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_sub,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A call to `reg-sub` associates a `query-id` WITH two functions.\\n\\n  The two functions provide \x27a mechanism\x27 for creating a node\\n  in the Signal Graph. When a node of type `query-id` is needed,\\n  the two functions can be used to create it.\\n\\n  The three arguments are:\\n\\n    - `query-id` - typically a namespaced keyword (later used in subscribe)\\n    - optionally, an `input signals` function which returns the input data\\n      flows required by this kind of node.\\n    - a `computation function` which computes the value (output) of the\\n      node (from the input data flows)\\n\\n  Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\\n  will trigger the need for a new `:sub-id` Signal Graph node (matching the\\n  query `[:sub-id 3 :blue]`). And, to create that node the two functions\\n  associated with `:sub-id` will be looked up and used.\\n\\n  Just to be clear: calling `reg-sub` does not immediately create a node.\\n  It only registers \x27a mechanism\x27 (the two functions) by which nodes\\n  can be created later, when a node is bought into existence by the\\n  use of `subscribe` in a `View Function`.\\n\\n  `reg-sub` arguments are:\\n\\n    - a `query-id` (typically a namespaced keyword)\\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\\n    - a function which computes the value of this kind of node (can be supplied in one of three ways)\\n\\n  The `computation function` is always the last argument supplied and has three ways to be called.\\n  Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\\n\\n  1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\\n     standard way to provide a `computation-function`\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            (fn [input-values query-vector]\\n              (:foo input-values)))\\n\\n  2. A single sugary tuple of `:-\x3e` and a 1-arity `computation-function`:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :-\x3e computation-fn)\\n\\n      This sugary variation allows you to pass a function that will expect only one parameter,\\n      namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\\n      expects two parameters which can cause unfortunate results when attempting to use\\n      clojure standard library functions, or other functions, in a functional manner.\\n\\n      For example, a significant number of subscriptions exist only to get a value\\n      from the `input-values`. As shown below, this subscription will simply retrieve\\n      the value associated with the `:foo` key in our db:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            (fn [db _]    ;; :\x3c---- trivial boilerplate we might want to skip over\\n              (:foo db)))\\n\\n      This is slightly more boilerplate than we might like to do,\\n      as we can use a keyword directly as a function, and we might like to do this:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :foo)  ;; :\x3c---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\\n\\n      By using `:-\x3e` our function would not contain the `query-vector`, and any\\n      missing keys would be represented as such:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :-\x3e :foo)\\n\\n      This form allows us to ignore the `query-vector` if our `computation-function`\\n      has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\\n      and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\\n\\n  3. A single sugary tuple of `:\x3d\x3e` and a multi-arity `computation-function`\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :\x3d\x3e computation-fn)\\n\\n      The `query-vector` can be broken into two components `[query-id \x26 optional-values]`, and\\n      some subscriptions require the `optional-values` for extra work within the subscription.\\n      To use them in variation #1, we need to destructure our `computation-function` parameters\\n      in order to use them.\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            (fn [db [_ foo]]\\n              [db foo]))\\n\\n      Again we are writing boilerplate just to reach our values, and we might prefer to\\n      have direction access through a parameter vector like `[input-values optional-values]`\\n      instead, so we might be able to use a multi-arity function directly as our `computation-function`.\\n      A rewrite of the above sub using this sugary syntax would look like this:\\n\\n          #!clj\\n          (reg-sub\\n            :query-id\\n            :\x3d\x3e vector)  ;; :\x3c---- Could also be `(fn [db foo] [db foo])`\\n\\n  The `computation function` is expected to take two arguments:\\n\\n    - `input-values` - the values which flow into this node (how is it wired into the graph?)\\n    - `query-vector` - the vector given to `subscribe`\\n\\n  and it returns a computed value (which then becomes the output of the node)\\n\\n  When `computation function` is called, the 2nd `query-vector` argument will be that\\n  vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\\n  then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\\n\\n  The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\\n  can vary in 3 ways, but whatever is there defines the `input signals` part\\n  of `the mechanism`, specifying what input values \\\x22flow into\\\x22 the\\n  `computation function` (as the 1st argument) when it is called.\\n\\n  So, `reg-sub` can be called in one of three ways, because there are three ways\\n  to define the input signals part. But note, the 2nd method, in which a\\n  `signals function` is explicitly supplied, is the most canonical and\\n  instructive. The other two are really just sugary variations.\\n\\n  **First variation** - no input signal function given:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\\n\\n     In the absence of an explicit `signals function`, the node\x27s input signal defaults to `app-db`\\n     and, as a result, the value within `app-db` (a map) is\\n     given as the 1st argument when `a-computation-fn` is called.\\n\\n\\n  **Second variation** - a signal function is explicitly supplied:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        signal-fn     ;; \x3c-- here\\n        computation-fn)\\n\\n  This is the most canonical and instructive of the three variations.\\n\\n  When a node is created from the template, the `signal function` will be called and it\\n  is expected to return the input signal(s) as either a singleton, if there is only\\n  one, or a sequence if there are many, or a map with the signals as the values.\\n\\n  The current values of the returned signals will be supplied as the 1st argument to\\n  the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\\n  this value will be either a singleton, sequence or map of them (paralleling\\n  the structure returned by the `signal function`).\\n\\n  This example `signal function` returns a 2-vector of input signals.\\n\\n      #!clj\\n      (fn [query-vec dynamic-vec]\\n         [(subscribe [:a-sub])\\n          (subscribe [:b-sub])])\\n\\n  The associated computation function must be written\\n  to expect a 2-vector of values for its first argument:\\n\\n      #!clj\\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\\n        ....)\\n\\n  If, on the other hand, the signal function was simpler and returned a singleton, like this:\\n\\n      #!clj\\n      (fn [query-vec dynamic-vec]\\n        (subscribe [:a-sub]))      ;; \x3c-- returning a singleton\\n\\n  then the associated computation function must be written to expect a single value\\n  as the 1st argument:\\n\\n      #!clj\\n      (fn [a query-vec]       ;; 1st argument is a single value\\n         ...)\\n\\n  Further Note: variation #1 above, in which an `input-fn` was not supplied, like this:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\\n\\n  is the equivalent of using this\\n  2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\\n\\n      #!clj\\n      (reg-sub\\n        :query-id\\n        (fn [_ _]  re-frame/app-db)   ;; \x3c--- explicit signal-fn\\n        a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\\n\\n  **Third variation** - syntax Sugar\\n\\n      #!clj\\n      (reg-sub\\n        :a-b-sub\\n        :\x3c- [:a-sub]\\n        :\x3c- [:b-sub]\\n        (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\\n          {:a a :b b}))\\n\\n  This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\\n  `signals-fn` you provide one or more pairs of `:\x3c-` and a subscription vector.\\n\\n  If you supply only one pair a singleton will be supplied to the computation function,\\n  as if you had supplied a `signal-fn` returning only a single value:\\n\\n      #!clj\\n      (reg-sub\\n        :a-sub\\n        :\x3c- [:a-sub]\\n        (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\\n          ...))\\n\\n  Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\\n  and the direction of arrows shows the flow of data and functions. The example from\\n  directly above is reproduced here:\\n\\n      #!clj\\n      (reg-sub\\n        :a-b-sub\\n        :\x3c- [:a-sub]\\n        :\x3c- [:b-sub]\\n        :-\x3e (partial zipmap [:a :b]))\\n\\n  For further understanding, read the tutorials, and look at the detailed comments in\\n  /examples/todomvc/src/subs.cljs.\\n\\n  See also: `subscribe`\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22dispatch\x22,\x22re-frame.core/dispatch\x22,1765071110,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.dispatch,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22event\x22,\x22event\x22,1941966969,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Queue `event` for processing (handling).\\n\\n  `event` is a vector and the first element is typically a keyword\\n  which identifies the kind of event.\\n\\n  The event will be added to a FIFO processing queue, so event\\n  handling does not happen immediately. It will happen \x27very soon\x27\\n  but not now. And if the queue already contains events, they\\n  will be processed first.\\n\\n  Usage:\\n\\n      #!clj\\n      (dispatch [:order \\\x22pizza\\\x22 {:supreme 2 :meatlovers 1 :veg 1}])\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22unwrap\x22,\x22re-frame.core/unwrap\x22,-1498080569,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.unwrap,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),cljs.core.PersistentArrayMap.EMPTY], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-event-fx\x22,\x22re-frame.core/reg-event-fx\x22,-63037421,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_event_fx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given event `handler` (function) for the given `id`. Optionally, provide\\n  an `interceptors` chain:\\n\\n    - `id` is typically a namespaced keyword  (but can be anything)\\n    - `handler` is a function: (coeffects-map event-vector) -\x3e effects-map\\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\\n\\n\\n  Example Usage:\\n\\n      #!clj\\n      (reg-event-fx\\n        :event-id\\n        (fn [cofx event]\\n          {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\\n\\n\\n  Or perhaps:\\n\\n      #!clj\\n      (reg-event-fx\\n        :namespaced/id           ;; \x3c-- namespaced keywords are often used\\n        [one two three]          ;; \x3c-- a seq of interceptors\\n        (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\\n          {:db (assoc db :some-key arg1)          ;; return a map of effects\\n           :fx [[:dispatch [:some-event arg2]]]}))\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22enqueue\x22,\x22re-frame.core/enqueue\x22,-170225827,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.enqueue,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, used when writing an interceptor\x27s `:before` function.\\n\\n  Adds the given collection of `interceptors` to those already in `context\x27s`\\n  execution `:queue`. It returns the updated `context`.\\n\\n  So, it provides a way for one interceptor to add more interceptors to the\\n  currently executing interceptor chain.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22get-coeffect\x22,\x22re-frame.core/get-coeffect\x22,1741350824,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.get_coeffect,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, typically used when writing an interceptor\x27s `:before` function.\\n\\n   When called with one argument, it returns the `:coeffects` map from within that `context`.\\n\\n   When called with two or three arguments, behaves like `clojure.core/get` and\\n   returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\\n   `nil` if `key` is not present.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22clear-event\x22,\x22re-frame.core/clear-event\x22,1624271650,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.clear_event,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\\n\\n  When called with no args, it will unregister all currently registered event handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  event handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22subscribe\x22,\x22re-frame.core/subscribe\x22,-774932115,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.subscribe,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query\x22,\x22query\x22,352022017,null),new cljs.core.Symbol(null,\x22dynv\x22,\x22dynv\x22,-405952138,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Given a `query` vector, returns a Reagent `reaction` which will, over\\n  time, reactively deliver a stream of values. So, in FRP-ish terms,\\n  it returns a `Signal`.\\n\\n  To obtain the current value from the Signal, it must be dereferenced:\\n\\n      #!clj\\n      (let [signal (subscribe [:items])\\n            value  (deref signal)]     ;; could be written as @signal\\n        ...)\\n\\n   which is typically written tersely as simple:\\n\\n      #!clj\\n      (let [items  @(subscribe [:items])]\\n        ...)\\n\\n\\n  `query` is a vector of at least one element. The first element is the\\n  `query-id`, typically a namespaced keyword. The rest of the vector\x27s\\n  elements are optional, additional values which parameterise the query\\n  performed.\\n\\n  `dynv` is an optional 3rd argument, which is a vector of further input\\n  signals (atoms, reactions, etc), NOT values. This argument exists for\\n  historical reasons and is borderline deprecated these days.\\n\\n  **Example Usage**:\\n\\n      #!clj\\n      (subscribe [:items])\\n      (subscribe [:items \\\x22blue\\\x22 :small])\\n      (subscribe [:items {:colour \\\x22blue\\\x22  :size :small}])\\n\\n  Note: for any given call to `subscribe` there must have been a previous call\\n  to `reg-sub`, registering the query handler (functions) associated with\\n  `query-id`.\\n\\n  **Hint**\\n\\n  When used in a view function BE SURE to `deref` the returned value.\\n  In fact, to avoid any mistakes, some prefer to define:\\n\\n      #!clj\\n      (def \x3csub  (comp deref re-frame.core/subscribe))\\n\\n  And then, within their views, they call  `(\x3csub [:items :small])` rather\\n  than using `subscribe` directly.\\n\\n  **De-duplication**\\n\\n  Two, or more, concurrent subscriptions for the same query will\\n  source reactive updates from the one executing handler.\\n\\n  See also: `reg-sub`\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22clear-fx\x22,\x22re-frame.core/clear-fx\x22,-894786861,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.clear_fx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\\n\\n  When called with no args, it will unregister all currently registered effect handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  effect handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-event-ctx\x22,\x22re-frame.core/reg-event-ctx\x22,15437106,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_event_ctx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given event `handler` (function) for the given `id`. Optionally, provide\\n  an `interceptors` chain:\\n\\n    - `id` is typically a namespaced keyword  (but can be anything)\\n    - `handler` is a function: context-map -\x3e context-map\\n\\n  You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\\n\\n  Example Usage:\\n\\n      #!clj\\n      (reg-event-ctx\\n        :event-id\\n        (fn [{:keys [coeffects] :as context}]\\n          (let [initial  {:db     (:db coeffects)\\n                          :event  (:event coeffects)\\n                          :fx     []}\\n                result   (-\x3e initial\\n                             function1\\n                             function2\\n                             function3)\\n                effects  (select-keys result [:db :fx])]\\n             (assoc context :effects effects))))\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22add-post-event-callback\x22,\x22re-frame.core/add-post-event-callback\x22,-441107040,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.add_post_event_callback,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Registers the given function `f` to be called after each event is processed.\\n\\n   `f` will be called with two arguments:\\n\\n    - `event`: a vector. The event just processed.\\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\\n\\n   This facility is useful in advanced cases like:\\n\\n     - you are implementing a complex bootstrap pipeline\\n     - you want to create your own handling infrastructure, with perhaps multiple\\n       handlers for the one event, etc.  Hook in here.\\n     - libraries providing \x27isomorphic javascript\x27 rendering on  Nodejs or Nashorn.\\n\\n  `id` is typically a keyword. If it supplied when an `f` is added, it can be\\n  subsequently be used to identify it for removal. See `remove-post-event-callback`.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-fx\x22,\x22re-frame.core/reg-fx\x22,1560429967,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_fx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given effect `handler` for the given `id`:\\n\\n    - `id` is keyword, often namespaced.\\n    - `handler` is a side-effecting function which takes a single argument and whose return\\n      value is ignored.\\n\\n  To use, first, associate `:effect2` with a handler:\\n\\n      #!clj\\n      (reg-fx\\n         :effect2\\n         (fn [value]\\n            ... do something side-effect-y))\\n\\n  Then, later, if an event handler were to return this effects map:\\n\\n      #!clj\\n      {:effect2  [1 2]}\\n\\n  then the `handler` `fn` we registered previously, using `reg-fx`, will be\\n  called with an argument of `[1 2]`.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22enrich\x22,\x22re-frame.core/enrich\x22,-1956662808,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.enrich,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which will run the given function `f` in the `:after`\\n  position.\\n\\n  `f` is called with two arguments: `db` and `event`, and is expected to\\n  return a modified `db`.\\n\\n  Unlike the `after` interceptor which is only about side effects, `enrich`\\n  expects `f` to process and alter the given `db` coeffect in some useful way,\\n  contributing to the derived data, flowing vibe.\\n\\n  If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\\n\\n  #### Example Use:\\n\\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\\n  the same text, then highlight their background, and report them via a warning\\n  at the bottom of the panel.\\n\\n  Almost any user action (edit text, add new todo, remove a todo) requires a\\n  complete reassessment of duplication errors and warnings. E.g. that edit\\n  just made might have introduced a new duplicate, or removed one. Same with\\n  any todo removal. So we need to re-calculate warnings after any CRUD events\\n  associated with the todos list.\\n\\n  Unless we are careful, we might end up coding subtly different checks\\n  for each kind of CRUD operation.  The duplicates check made after\\n  \x27delete todo\x27 event might be subtly different to that done after an\\n  editing operation. Nice and efficient, but fiddly. A bug generator\\n  approach.\\n\\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\\n  every time there is ANY change. It will inspect all the todos, and\\n  reset ALL FLAGS every time (overwriting what was there previously)\\n  and fully recalculate the list of duplicates (displayed at the bottom?).\\n\\n  \x3ca href\x3d\\\x22https://twitter.com/nathanmarz/status/879722740776939520\\\x22 target\x3d\\\x22_blank\\\x22\x3ehttps://twitter.com/nathanmarz/status/879722740776939520\x3c/a\x3e\\n\\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\\n  we keep the handlers simple and yet we ensure this important step\\n  (of getting warnings right) is not missed on any change.\\n\\n  We can test `f` easily - it is a pure function - independently of\\n  any CRUD operation.\\n\\n  This brings huge simplicity at the expense of some re-computation\\n  each time. This may be a very satisfactory trade-off in many cases.\\n\\n  #### Returning nil\\n\\n  In some cases, it\x27s useful to apply a change to specific situations that can\\n  be determined at runtime instead of when defining the handler with an\\n  `:enrich` interceptor. Instead of forcing you to return the `db` from every\\n  non-applicable branch, you can return `nil` to use the given `db` value:\\n\\n      #!clj\\n      (def set-last-update\\n        (core/enrich\\n          (fn [{db :db} [_ {user :user}]]\\n            (when (active-user? user)  ;; \x3c- Only perform an update if user is active\\n              ...))))\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-global-interceptor\x22,\x22re-frame.core/reg-global-interceptor\x22,-2081719141,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_global_interceptor,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22interceptor\x22,\x22interceptor\x22,-1526696693,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Registers the given `interceptor` as a global interceptor. Global interceptors are\\n   included in the processing chain of every event.\\n\\n   When you register an event handler, you have the option of supplying an\\n   interceptor chain. Any global interceptors you register are effectively\\n   prepending to this chain.\\n\\n   Global interceptors are run in the order that they are registered.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22console\x22,\x22re-frame.core/console\x22,1914748698,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.console,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22level\x22,\x22level\x22,-1363938217,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility logging function which is used internally within re-frame to produce\\n  warnings and other output. It can also be used by libraries which\\n  extend re-frame, such as effect handlers.\\n\\n  By default, it will output the given `args` to `js/console` at the given log `level`.\\n  However, an application using re-frame can redirect `console` output via `set-loggers!`.\\n\\n  `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\\n\\n  Example usage:\\n\\n      #!clj\\n      (console :error \\\x22Sure enough it happened:\\\x22 a-var \\\x22and\\\x22 another)\\n      (console :warn \\\x22Possible breach of containment wall at:\\\x22 dt)\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22clear-cofx\x22,\x22re-frame.core/clear-cofx\x22,583971922,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.clear_cofx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\\n\\n  When called with no args, it will unregister all currently registered coeffect handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  coeffect handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-cofx\x22,\x22re-frame.core/reg-cofx\x22,-1104161380,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_cofx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given coeffect `handler` for the given `id`, for later use\\n  within `inject-cofx`:\\n\\n    - `id` is keyword, often namespaced.\\n    - `handler` is a function which takes either one or two arguments, the first of which is\\n       always `coeffects` and which returns an updated `coeffects`.\\n\\n  See also: `inject-cofx`\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22after\x22,\x22re-frame.core/after\x22,705151839,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.after,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which runs the given function `f` in the `:after`\\n  position, presumably for side effects.\\n\\n  `f` is called with two arguments: the `:effects` value for `:db`\\n  (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\\n  Its return value is ignored, so `f` can only side-effect.\\n\\n  An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\\n\\n     - `f` runs schema validation (reporting any errors found).\\n     - `f` writes to localstorage.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22register-handler\x22,\x22re-frame.core/register-handler\x22,772396373,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.register_handler,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Deprecated. Use `reg-event-db` instead.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22set-loggers!\x22,\x22re-frame.core/set-loggers!\x22,886929143,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.set_loggers_BANG_,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22new-loggers\x22,\x22new-loggers\x22,-1268568509,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22re-frame outputs warnings and errors via the API function `console`\\n   which, by default, delegates to `js/console`\x27s default implementation for\\n  `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\\n   you can override that behaviour with your own functions.\\n\\n  The argument `new-loggers` should be a map containing a subset of they keys\\n  for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\\n  or `:groupEnd`.\\n\\n  Example Usage:\\n\\n      #!clj\\n      (defn my-logger      ;; my alternative logging function\\n        [\x26 args]\\n        (post-it-somewhere (apply str args)))\\n\\n      ;; now install my alternative loggers\\n      (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\\n   \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22assoc-effect\x22,\x22re-frame.core/assoc-effect\x22,-114683447,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.assoc_effect,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, typically used when writing an interceptor\x27s `:after` function.\\n\\n   Adds or updates a key/value pair in the `:effects` map within `context`. \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22on-changes\x22,\x22re-frame.core/on-changes\x22,1765357575,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.on_changes,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22f\x22,\x22f\x22,43394975,null),new cljs.core.Symbol(null,\x22out-path\x22,\x22out-path\x22,-923103991,null),new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22in-paths\x22,\x22in-paths\x22,-1809668720,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which will observe N paths within `db`, and if any of them\\n  test not `identical?` to their previous value  (as a result of a event handler\\n  being run), then it will run `f` to compute a new value, which is then assoc-ed\\n  into the given `out-path` within `db`.\\n\\n  Example Usage:\\n\\n      #!clj\\n      (defn my-f\\n        [a-val b-val]\\n        ... some computation on a and b in here)\\n\\n      ;; use it\\n      (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\\n\\n      (reg-event-db\\n        :event-id\\n        [... my-interceptor ...]  ;; \x3c-- ultimately used here\\n        (fn [db v]\\n           ...))\\n\\n\\n  If you put this interceptor on handlers which might change paths `:a` or `:b`,\\n  it will:\\n\\n    - call `f` each time the value at path `[:a]` or `[:b]` changes\\n    - call `f` with the values extracted from `[:a]` `[:b]`\\n    - assoc the return value from `f` into the path  `[:c]`\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22clear-subscription-cache!\x22,\x22re-frame.core/clear-subscription-cache!\x22,-8362855,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.clear_subscription_cache_BANG_,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Removes all subscriptions from the cache.\\n\\n  This function can be used at development time or test time. Useful when hot reloading\\n  namespaces containing subscription handlers. Also call it after a React/render exception,\\n  because React components won\x27t have been cleaned up properly. And this, in turn, means\\n  the subscriptions within those components won\x27t have been cleaned up correctly. So this\\n  forces the issue.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22get-effect\x22,\x22re-frame.core/get-effect\x22,-1346481552,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.get_effect,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22not-found\x22,\x22not-found\x22,1011451547,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, used when writing interceptors, typically within an `:after` function.\\n\\n   When called with one argument, returns the `:effects` map from the `context`.\\n\\n   When called with two or three arguments, behaves like `clojure.core/get` and\\n   returns the value mapped to `key` in the effects map, `not-found` or\\n   `nil` if `key` is not present.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22register-sub\x22,\x22re-frame.core/register-sub\x22,-772926397,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.register_sub,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Deprecated. Use `reg-sub-raw` instead.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22path\x22,\x22re-frame.core/path\x22,-3666115,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.path,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.Symbol(null,\x22args\x22,\x22args\x22,-1338879193,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\\n  the event handler is given a specific part of `app-db` to change, not all of `app-db`.\\n\\n  The interceptor has both a `:before` and `:after` functions. The `:before` replaces\\n  the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\\n  and it grafts the handler\x27s return value back into db, at the right path.\\n\\n  Examples:\\n\\n      #!clj\\n      (path :some :path)\\n      (path [:some :path])\\n      (path [:some :path] :to :here)\\n      (path [:some :path] [:to] :here)\\n\\n  Example Use:\\n\\n      #!clj\\n      (reg-event-db\\n        :event-id\\n        (path [:a :b])  ;; \x3c-- used here, in interceptor chain\\n        (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\\n          ... new-b))   ;; returns a new value for that path (not the entire db)\\n\\n  Notes:\\n\\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\\n    2. if `:effects` contains no `:db` effect, can\x27t graft a value back in.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22clear-global-interceptor\x22,\x22re-frame.core/clear-global-interceptor\x22,166960890,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.clear_global_interceptor,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\\n\\n  When called with no args, it will unregister all currently registered global interceptors.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  global interceptors, it will unregister the associated interceptor. Will produce a warning to\\n  console if it finds no matching registration.\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22clear-sub\x22,\x22re-frame.core/clear-sub\x22,395526338,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.clear_sub,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22query-id\x22,\x22query-id\x22,-1180306927,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\\n\\n  When called with no args, it will unregister all currently registered subscription handlers.\\n\\n  When given one arg, assumed to be the `id` of a previously registered\\n  subscription handler, it will unregister the associated handler. Will produce a warning to\\n  console if it finds no matching registration.\\n\\n  NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22trim-v\x22,\x22re-frame.core/trim-v\x22,-1158424979,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.trim_v,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),cljs.core.PersistentArrayMap.EMPTY], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22-\x3einterceptor\x22,\x22re-frame.core/-\x3einterceptor\x22,6499190,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.__GT_interceptor,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22\x26\x22,\x22\x26\x22,-2144855648,null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22as\x22,\x22as\x22,1148689641),new cljs.core.Symbol(null,\x22m\x22,\x22m\x22,-1021758608,null),new cljs.core.Keyword(null,\x22keys\x22,\x22keys\x22,1068423698),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22before\x22,\x22before\x22,6839139,null),new cljs.core.Symbol(null,\x22after\x22,\x22after\x22,-2059438855,null)], null)], null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function for creating interceptors.\\n\\n  Accepts three optional, named arguments:\\n\\n     - `:id` - an id for the interceptor (decorative only)\\n     - `:before` - the interceptor\x27s before function\\n     - `:after`  - the interceptor\x27s after function\\n\\n  Example use:\\n\\n      #!clj\\n      (def my-interceptor\\n        (-\x3einterceptor\\n         :id     :my-interceptor\\n         :before (fn [context]\\n                   ... modifies and returns `context`)\\n         :after  (fn [context]\\n                   ... modifies and returns `context`)))\\n\\n  Notes:\\n\\n    - `:before` functions modify and return their `context` argument. Sometimes they\\n      only side effect, in which case, they\x27ll perform the side effect and return\\n      `context` unchanged.\\n    - `:before` functions often modify the `:coeffects` map within `context` and,\\n      if they do, then they should use the utility functions `get-coeffect` and\\n      `assoc-coeffect`.\\n    - `:after` functions modify and return their `context` argument. Sometimes they\\n      only side effect, in which case, they\x27ll perform the side effect and return\\n      `context` unchanged.\\n    - `:after` functions often modify the `:effects` map within `context` and,\\n      if they do, then they should use the utility functions `get-effect`\\n      and `assoc-effect`\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22make-restore-fn\x22,\x22re-frame.core/make-restore-fn\x22,-1130647527,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.make_restore_fn,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22This is a utility function, typically used in testing.\\n\\n  It checkpoints the current state of re-frame and returns a function which, when\\n  later called, will restore re-frame to the checkpointed state.\\n\\n  The checkpoint includes `app-db`, all registered handlers and all subscriptions.\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22purge-event-queue\x22,\x22re-frame.core/purge-event-queue\x22,1051371119,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.purge_event_queue,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(cljs.core.PersistentVector.EMPTY),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Removes all events currently queued for processing\x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22debug\x22,\x22re-frame.core/debug\x22,1759164285,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.debug,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),cljs.core.PersistentArrayMap.EMPTY], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22assoc-coeffect\x22,\x22re-frame.core/assoc-coeffect\x22,-832544285,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.assoc_coeffect,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22context\x22,\x22context\x22,810340414,null),new cljs.core.Symbol(null,\x22key\x22,\x22key\x22,124488940,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22A utility function, typically used when writing an interceptor\x27s `:before` function.\\n\\n   Adds or updates a key/value pair in the `:coeffects` map within `context`. \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22reg-event-db\x22,\x22re-frame.core/reg-event-db\x22,418153612,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.reg_event_db,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22interceptors\x22,\x22interceptors\x22,93748576,null),new cljs.core.Symbol(null,\x22handler\x22,\x22handler\x22,1444934915,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Register the given event `handler` (function) for the given `id`. Optionally, provide\\n  an `interceptors` chain:\\n\\n    - `id` is typically a namespaced keyword  (but can be anything)\\n    - `handler` is a function: (db event) -\x3e db\\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\\n\\n  Example Usage:\\n\\n      #!clj\\n      (reg-event-db\\n        :token\\n        (fn [db event]\\n          (assoc db :some-key (get event 2)))  ;; return updated db\\n\\n  Or perhaps:\\n\\n      #!clj\\n      (reg-event-db\\n        :namespaced/id           ;; \x3c-- namespaced keywords are often used\\n        [one two three]          ;; \x3c-- a seq of interceptors\\n        (fn [db [_ arg1 arg2]]   ;; \x3c-- event vector is destructured\\n          (-\x3e db\\n            (dissoc arg1)\\n            (update :key + arg2))))   ;; return updated db\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22inject-cofx\x22,\x22re-frame.core/inject-cofx\x22,506211767,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.inject_cofx,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null),new cljs.core.Symbol(null,\x22value\x22,\x22value\x22,1946509744,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Given an `id`, and an optional, arbitrary `value`, returns an interceptor\\n  whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\\n  \x27coeffect handler\x27 identified by the `id`.\\n\\n  The previous association of a `coeffect handler` with an `id` will have\\n  happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\\n\\n  Within the created interceptor, this \x27looked up\x27 `coeffect handler` will\\n  be called (within the `:before`) with two arguments:\\n\\n  - the current value of `:coeffects`\\n  - optionally, the originally supplied arbitrary `value`\\n\\n  This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\\n\\n  **Example of `inject-cofx` and `reg-cofx` working together**\\n\\n\\n  First - Early in app startup, you register a `coeffect handler` for `:datetime`:\\n\\n      #!clj\\n      (re-frame.core/reg-cofx\\n        :datetime                        ;; usage  (inject-cofx :datetime)\\n        (fn coeffect-handler\\n          [coeffect]\\n          (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\\n\\n  Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\\n\\n      #!clj\\n      (re-frame.core/reg-event-fx            ;; when registering an event handler\\n        :event-id\\n        [ ... (inject-cofx :datetime) ... ]  ;; \x3c-- create an injecting interceptor\\n        (fn event-handler\\n          [coeffect event]\\n            ;;... in here can access (:now coeffect) to obtain current datetime ...\\n          )))\\n\\n  **Background**\\n\\n  `coeffects` are the input resources required by an event handler\\n  to perform its job. The two most obvious ones are `db` and `event`.\\n  But sometimes an event handler might need other resources.\\n\\n  Perhaps an event handler needs a random number or a GUID or the current\\n  datetime. Perhaps it needs access to a DataScript database connection.\\n\\n  If an event handler directly accesses these resources, it stops being\\n  pure and, consequently, it becomes harder to test, etc. So we don\x27t\\n  want that.\\n\\n  Instead, the interceptor created by this function is a way to \x27inject\x27\\n  \x27necessary resources\x27 into the `:coeffects` (map) subsequently given\\n  to the event handler at call time.\\n\\n  See also `reg-cofx`\\n  \x22], null)], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.core\x22,\x22remove-post-event-callback\x22,\x22re-frame.core/remove-post-event-callback\x22,-1601893792,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.core.remove_post_event_callback,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\x22arglists\x22,\x22arglists\x22,1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\x22id\x22,\x22id\x22,252129435,null)], null)),new cljs.core.Keyword(null,\x22doc\x22,\x22doc\x22,1913296891),\x22Unregisters a post event callback function, identified by `id`.\\n\\n  Such a function must have been previously registered via `add-post-event-callback`\x22], null)], null)]),sci.configs.re_frame.re_frame.rfns);\nsci.configs.re_frame.re_frame.re_frame_db_namespace \x3d sci.core._copy_ns(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Symbol(null,\x22app-db\x22,\x22app-db\x22,-1788829467,null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\x22name\x22,\x22name\x22,1843675177),new cljs.core.Symbol(\x22re-frame.db\x22,\x22app-db\x22,\x22re-frame.db/app-db\x22,1918166498,null),new cljs.core.Keyword(null,\x22val\x22,\x22val\x22,128701612),re_frame.db.app_db,new cljs.core.Keyword(null,\x22meta\x22,\x22meta\x22,1499536964),cljs.core.PersistentArrayMap.EMPTY], null)], null),sci.configs.re_frame.re_frame.rfdbns);\nsci.configs.re_frame.re_frame.namespaces \x3d new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Symbol(null,\x22re-frame.core\x22,\x22re-frame.core\x22,-1549073474,null),sci.configs.re_frame.re_frame.re_frame_namespace,new cljs.core.Symbol(null,\x22re-frame.db\x22,\x22re-frame.db\x22,983930750,null),sci.configs.re_frame.re_frame.re_frame_db_namespace], null);\nsci.configs.re_frame.re_frame.config \x3d new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\x22namespaces\x22,\x22namespaces\x22,-1444157469),sci.configs.re_frame.re_frame.namespaces], null);\n");
SHADOW_ENV.evalLoad("scittle.re_frame.js", true , "goog.provide(\x27scittle.re_frame\x27);\nscittle.core.register_plugin_BANG_(new cljs.core.Keyword(\x22scittle.re-frame\x22,\x22re-frame\x22,\x22scittle.re-frame/re-frame\x22,1536840200),sci.configs.re_frame.re_frame.config);\n");
SHADOW_ENV.evalLoad("shadow.module.scittle.re-frame.append.js", false , "\nshadow.cljs.devtools.client.env.module_loaded(\x27scittle.re-frame\x27);\n;\nSHADOW_ENV.setLoaded(\x22re_frame.interop.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.db.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.loggers.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.utils.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.settings.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.registrar.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.trace.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.interceptor.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.events.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.subs.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.router.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.fx.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.cofx.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.std_interceptors.js\x22);\nSHADOW_ENV.setLoaded(\x22re_frame.core.js\x22);\nSHADOW_ENV.setLoaded(\x22sci.configs.re_frame.re_frame.js\x22);\nSHADOW_ENV.setLoaded(\x22scittle.re_frame.js\x22);\nSHADOW_ENV.setLoaded(\x22shadow.module.scittle.re-frame.append.js\x22);");